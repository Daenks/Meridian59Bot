# GreetWondeR 1.8.2 (Eggdrop 1.x Greet TCL Script)
# ---------------
# Released: Tue Nov 2 1999 
# Author: Wingman <Wingman@WINGDesign.de>
#         http://www.WINGDesign.de/
# GreetWondeR Homepage: http://www.WINGDesign.de/greetwonder/
# GreetWondeR Mailinglist: GreetWondeR@WINGDesign.de
# To subscribe...
# ---------------

### FILE SETTINGS

# [dir] Where should the data of greetwonder.tcl be saved?
# Note: all files, generated by greetwonder, are stored in this directory.
# Default: ./greet
set greet(dir) "./greet"

# [file] This is the file, where all user-defined variables are saved
# This file will be stored in directory $greet(dir) (e.g.: ./greet/greet.dat)
# Default: greet.dat
set greet(data) "greet.dat"

# [file] Where should the nick-greets be saved?
# This file will be stored in directory $greet(dir) (e.g.: ./greet/nicks.dat)
# Default: nicks.dat
set greet(nicks) "nicks.dat"

### GREET SETTINGS
# Most of these settings below are only default values and can be changed via
# dcc commands. (try '.greethelp')

# [lines] How many lines are allowed for greets?
# (HINT: 0 to disable)
# Default: 5
set greet(max) "5"

# [NOTICE/PRIVMSG] How should i greet the users?
# Note: .greethow [channel] [+flag] <notice/msg>
# Default: NOTICE
set greet(how) "MSG"

# [all/known/unknown] Should i greet all, known or only unkown users?
# Note: .greetwho [channel] <all/known/unknown>
# Default: all
set greet(who) "all"

# [0/1] Random greets by default on or off?
# Note: .greetrandom [channel] <on/off>
# Default: off
set greet(random) "off"

# [on/off] If there are more than 1 flag greets specified (e.g. +A greet1, +B 
# greet2) and user1 with flags +AB joins, should he be greeted with both lines
# or only with the first (depending on flag hierarchie, definied below).
# ---
# off: only with first flag-greet, that matches his/her attributes (flags)
# on: with all flag-greets, that matches his/her attributes (flags)
# Default: off
set greet(flag_greet_seperation) "off"

# [string] What's the main greet hierarchie?
# Examples: set greet(hierarchie) "nick chan mask"
#           set greet(hierarchie) "chan nick mask"
#           set greet(hierarchie) "mask nick chan" (got it? :)
# ---
# HINT: You can disable greets by removing the value from the hierarchie:
#   Then all commands, linked to this value, are not available.
#   e.g. if you don't want/need any nickgreets:
#     set greet(hierarchie) "chan mask"
#   or if you don't want/need any maskgreets:
#     set greet(hierarchie) "nick chan"
# ---
# Default: nick chan mask
set greet(hierarchie) "nick chan mask"

# [string] What's the flag hierarchie for greets?
# e.g. if this is set to "nmofv" then n greets come b4 m greets, b4 o greets...
# Default: nmofvfxp
set greet(sorted) "nmovfxp"

### FLOOD SETTINGS

# [0/1] Enables the flood protection for this tcl. This means,
# if there's a flood join, the tcl refuses the greets for n minutes
# (shutdown time is set below)
# Default: 1
set greet(floodprotect) "1"

# [joins:secs] If there are x joins in y secs, greetwonder will shutdown itself,
# if greet(floodprotect) is 1.
# Default: 8:10
set greet(flood_join) "8:10"

# [mins] How long should the tcl shutdown itself after a flood attack?
# Default: 5
set greet(noresponse) "5"

# [bytes:sec] How many bytes/sec should be send to server before 
# activating the GreetWondeR (Excess) Flood Protection (G(E)FP). If you don't 
# want to queue greets via tcl, then set it to 0:0 and the eggdrop "queue" 
# system will take the rest (...and perhaps will excess flood...)
# ---
# Support for DONTFLOOD.PATCH/QSTUFF.PATCH:
# This is a patch for eggdrop1.3.28+, which integrates this flood-protection
# in your src and prevents your eggdrop from excess flooding, but it's not yet
# integrated in the eggsrc. Ask the author G`Quann <eggfan@3dart.de> for his
# 'dontflood' or 'qstuff' patch.
# ---
# If your bots excess floods, reduce this value...
# Default: 512:10 
set greet(sendq) "512:10" 

# [cmds] How many cmds should be send to server before activating GFP?
# (per x seconds, defined above). 
# Default: 10
set greet(sendc) "10"

# [bytes] How many bytes can be stored in the queue? Others will be skipped 
# to prevent your eggie from quiting via excess flood.
# Default: 2048 
set greet(maxqueue) "2048"

# [cmds] How many cmds can be stored in the queue? Others will be skipped
# to prevent your eggdrop from quitting via excess flood.
# Default: 10
set greet(maxcmds) "10"

### BINDING SETTINGS

# [globalflag|chanflag] Who should be able to use +greetfile/greetreset and
# greetstatus?
# Default: n|-
set greet(gbind) "n|-"

# [globalflag|chanflag] Who should be able to set/del nickgreets, and also to
# turn on/off greets (includes greetnickview)
# Default: m|-
set greet(nbind) "m|-"

# [globalflag|chanflag] All this commands have an integrated chanflag check, so
# if an user is +n on #chan1, he is not able to set greets on #chan2
# Commands: +/-greet, +/-greetmask, greethow, greetwho, greetview,
# greethelp, greetmove
# Default: m|n
set greet(rbind) "m|n"

# ---
# CODE (Stop editing, if you are not familiar with TCL)
# ---

set greet(version) "1.8.2"
set greet(rdate) "Tue Nov 2 1999"

# --- essential procs ---
# greet:isdigit <string> -> if string is digit, return 1 else 0
# greet:refresh -> refreshes greets from file(s)
# greet:getdate <what> -> returns current date/time
# greet:sort <flaglist> <sort-order> -> sorts the flagliste by sort-order
# greet:flag2norm <flag> -> returns the real expression for +flag
# greet:ispermown <handle> -> returns 1, if handle is permowner else 0
# greet:sl <word1 word2 ...> -> returns [string length word] of the longest
#                               word
# greet:lend <from> <string> -> returns word nr. $from till end of string
# greet:load <var> -> returns value of var, saved in $greet(data)
# greet:save <var> <value> -> saves "var = value" to $greet(data)
# greet:getfile <file> -> returns content of file

proc greet:sort { flaglist sort } {
  global greet
  if {[llength $flaglist] == 1} { return $flaglist }
  foreach flag [split $greet(sorted) ""] {
    set test [lsearch -exact $flaglist +$flag]
    if {$test != -1} { 
      if {![info exists ret]} { set ret "+$flag" } { append ret " +$flag" }
      regsub -all "$flag" "$flaglist" @ flaglist
    }
  }
  if {![info exists ret]} {set ret "$flag"} {foreach flag $flaglist {if {$flag != "+@"} {append ret " $flag"}}}
  if {[info exists ret]} {return $ret}
  return ""
}

proc greet:getdate { what } {
  switch -exact $what {
    "time" { return [strftime "%H:%M"] }
    "date" { return [strftime "%d %b %Y"] }
  }
}

proc greet:isdigit { string } {
  if {$string == ""} { return 0 }
  foreach foo [split $string ""] { if {[lsearch -exact "0 1 2 3 4 5 6 7 8 9" $foo] == -1} { set goo 1 } }
  if {[info exists goo]} { return 0 }
  return 1 
}

proc greet:refresh {} {
  global greet 
  global changreets nickgreets hostgreets
  foreach chanz [greet:getchannels] {
    set changreets($chanz) [greet:getfile $greet(dir)/channels/[string trimleft $chanz #].dat]
    set maskgreets($chanz) [greet:getfile $greet(dir)/channels/[string trimleft $chanz #].dat]
  }
  set nickgreets [greet:getfile $greet(dir)/$greet(nicks)]
  return 1
}  

proc greet:flag2norm { flag } {
  if {[string match "+?" $flag]} { set flag [string trimleft $flag +] }
  if {$flag == "-"} { return "-" }
  switch -exact "$flag" {
    "h" { return "high-light flag" }
    "m" { return "master" }
    "p" { return "party-line" }
    "x" { return "xfer" }
    "t" { return "botnet-master" }
    "j" { return "janitor" }
    "c" { return "common" }
    "u" { return "unshared" }
    "b" { return "bot" }
    "d" { return "deop" }
    "n" { return "owner" }
    "o" { return "op" }
    "f" { return "friend" }
    "k" { return "auto-kick" }
    "v" { return "voice" }
    "q" { return "quit" }
    "a" { return "auto-op" }
    "g" { return "auto-voice" }
    "w" { return "wasop-test" }
    default { return "user-defined" }
  }
  return "$flag"
}

proc greet:ispermown { handle } {
  global owner
  if {![info exists owner]|| $owner == ""} {return 0}
  if {$handle == "*"} {return 0}
  foreach zowner [split [string trim $owner " "] ,] {
    if {[string tolower $handle] == [string tolower $zowner]} { set isowner 1 } }
    if {[info exists isowner]} {
    if {[greet:matchattr $handle n ""]} {return 1} {return 0}
  }
  return 0
}

proc greet:sl { string } {
  foreach var $string { if {![info exists cl]} { set cl [string length $var] } { set cl2 [string length $var] ; if {$cl2 > $cl} { set cl $cl2 } } }
  return $cl
}

proc greet:stl { string } {
  return [string tolower $string]
}

proc greet:lend { start string } {
  set count 0
  foreach word [split $string " "] {
    incr count
    if {$count > $start} { if {![info exists foo]} {set foo $word} {append foo " $word"} }
  }
  if {[info exists foo]} {return $foo} 
  return ""
}

proc greet:load { varname } {
  global greet
  set file [open $greet(dir)/$greet(data) r]
  while {![eof $file]} {
    set line [gets $file]
    if {[greet:stl [lindex $line 0]] == $varname} {
      close $file
      return [lrange $line 2 end]
    }
  }
  close $file
  return ""
}

proc greet:save { name value } {
  global greet
  set file [open $greet(dir)/$greet(data) r]
  while {![eof $file]} {
    set line [gets $file]
    if {[lindex $line 0] != $name} {
      lappend datalist $line
    }
  }
  close $file
  set file [open $greet(dir)/$greet(data) w]
  foreach line $datalist { if {$line != ""} {puts $file $line} }
  puts $file "$name = $value"
  close $file
  return "$value"
}

proc greet:getfile { file } {
  if {![file exists $file]} {return ""}
  set file2read [open $file r]
  while {![eof $file2read]} {
    set line "[gets $file2read]"
    if {$line != ""} {lappend inhalt $line}
  }
  close $file2read
  if {![info exists inhalt]} {return ""} 
  return "$inhalt"
}
# --- end: essential procs ---

# --- join/flood protection procs---
# greet:splt -> adds $uhost to splitlist
# greet:rejn -> dels $uhost from splitlist
# greet:delsplit -> dels $uhost from splitlist 
# greet:flooddetect -> main flood detection proc
# greet:decr -> decreses $greetjoins($chan)
# greet:startup <chan> -> restarts greets on chan after flood attack

proc greet:splt { nick uhost hand chan } {
  global greetsplit greetstimer
  if {![info exists greetsplit]} { set greetsplit "" }
  if {[lsearch "$greetsplit" $uhost] == -1} {
    if {$greetsplit == ""} { set greetsplit "$uhost" } { append greetsplit " $uhost" }
    set greetstimer($uhost) [timer 20 "greet:delsplt $uhost"]
  }
}

proc greet:rejn { nick uhost hand chan } {
  global greetsplit greetstimer
  if {![info exists greetsplit]} { set greetsplit "" ; return 1}
  if {[lsearch "$greetsplit" $uhost] == -1} { return 1 }
    foreach var $greetsplit {
    if {$var != "" || $var != $uhost} {if {![info exists newgsplit]} {set newgsplit $var} {append newgsplit " $var"} }
  }
  if {![info exists newgsplit]} {set greetsplit ""} {set greetsplit $newgsplit}
  catch { killtimer $greetsplit($uhost) }
}

proc greet:delsplt { uhost } {
  global greetsplit greetstimer
  if {![info exists greetsplit]} { set greetsplit "" ; return 1 }
  if {[lsearch "$greetsplit" $uhost] == -1} { return 1 }
    foreach var $greetsplit {
    if {$var != "" || $var != $uhost} {if {![info exists newgsplit]} {set newgsplit $var} {append newgsplit " $var"} }
  }
  if {![info exists newgsplit]} {set greetsplit ""} {set greetsplit $newgsplit}
  catch { killtimer $greetsplit($uhost) }
}

proc greet:flooddetect { nick uhost handle chan } {
  global greet 
  global greetjoins greetflood greetsplit
  global botnick
  set chan [string tolower $chan]
  if {$nick == $botnick} { return 1 }
  if {[greet:matchattr $handle o|o $chan]} { return 0 }
  if {![info exists greetsplit]} { set greetsplit "" }
  if {[lsearch -exact "$greetsplit" $uhost] != -1} { return 1 }
  if {![info exists greetjoins($chan)]} { set greetjoins($chan) 0 }
  incr greetjoins($chan)
  utimer [lindex [split $greet(flood_join) :] 1] "greet:decr $chan"
  if {$greetjoins($chan) > [lindex [split $greet(flood_join) :] 0]} {
    if {[info exists greetflood([greet:stl $chan])]} { return 0 }
    putlog "GreetWondeR $greet(version) - FLOOD JOINS detected on $chan: Shutting down greets for $chan."
    timer $greet(noresponse) "greet:startup $chan"
    set greetflood([greet:stl $chan]) 1
    return 0
  }  
}

proc greet:decr { chan } {
  global greetjoins
  set greetjoins($chan) [expr $greetjoins($chan) - 1]
  if {$greetjoins($chan) == 0} { unset greetjoins($chan) }
}

proc greet:startup { chan } {
  global greetflood greet
  putlog "GreetWondeR $greet(version) - FLOOD JOINS on $chan seem to be over: Restarting greets for $chan."
  if {[info exists greetflood([greet:stl $chan])]} { unset greetflood([greet:stl $chan]) }
}
# --- end: join/flood detection procs

# --- compatibility procs ---
# greet:matchattr <handle> <flag> <chan> 
# greet:getchannels -> returns list of chans
# greet:getxtra <what>
# greet:setxtra <handle> <what>
      
proc greet:matchattr { handle flag chan } {
  global greet
  if {$chan == ""} {
    switch -exact $greet(bottype) {
      "1.1" { return [matchattr $handle [string trimleft [string trimleft $flag |] +]] }
      "1.3" { return [matchattr $handle $flag] } 
      "1.4" { return [matchattr $handle $flag] }
      "1.2" { return [matchattr $handle $flag] }
    }    
  }
  if {[string index $flag 0] != "|"} { set flag "|$flag" }
  switch -exact $greet(bottype) {
    "1.1" { return [matchchanattr $handle [string trimleft [string trimleft $flag |] +] $chan] }
    "1.3" { return [matchattr $handle $flag $chan] } 
    "1.2" { return [matchattr $handle $flag $chan] }
    "1.4" { return [matchattr $handle $flag $chan] }
  }
}

proc greet:getchannels {} {
  global greet
  global chanfile
  switch -exact $greet(bottype) {
    "1.1" { return [channels] }
    "1.2" { return [channels] }
  }
  if {![file exists $chanfile]} { return [channels] }
  set file [open $chanfile r]
  while {![eof $file]} {
    set line [gets $file]
    if {($line != "") && (![string match "#*" $line])} {
      set chan [lindex $line 2]
      if {![info exists channels]} {set channels "$chan"} {append channels " $chan"} 
    }
  }
  close $file
  if {![info exists channels]} {return ""} 
  return $channels
}    

# --- end: compatibility procs ---

# --- init procs ---
# greet:putinit <what> <idx> <string> 
# greet:init <what> <idx>
proc greet:putinit { what idx string } {
  if {$what == "start"} { putlog "$string" } { putdcc $idx "$string" } 
}

proc greet:createdata {} {
  global greet
  set file [open $greet(dir)/$greet(data) w]
  puts $file "# TCL: GreetWondeR $greet(version)"
  puts $file "# This file was created on [greet:getdate date] at [greet:getdate time]."
  puts $file "# Usage: varname = value"
  puts $file "# If a line starts with '#', it will be ignored (comment)."
  puts $file "greet(how) = $greet(how)"
  puts $file "greet(who) = $greet(who)"
  foreach chan [greet:getchannels] {
    set chan [greet:stl $chan]
    puts $file "greet($chan) = 1"
    puts $file "greetall($chan) = $greet(who)"
    set greetall($chan) $greet(who)
    puts $file "greethow($chan) = $greet(how)"
    set greethow($chan) $greet(how)
  }
  close $file
}

proc greet:init { what idx } {
  global greet
  global nickgreets changreets hostgreets
  global footimer dftimer version
  global greethow greetall greetrand
  set greet(bottype) "[string range $version 0 2]"
  if {[lsearch -exact "1.1 1.2 1.3 1.4" $greet(bottype)] == -1} {
    putlog "-----------"
    putlog "GreetWondeR $greet(version) - UNSUPPORTED EGGDROP: $greet(bottype).x ([lindex $version 0])"
    putlog "  This greet script works only on 1.x (1.1/2/3/4)"
    putlog "  See 'readme.txt' for more information on this problem."
    putlog "GreetWondeR $greet(version) - NOT LOADED"
    putlog "-----------"
    return 0
  }
  if {[lsearch -exact "notice privmsg" [greet:stl $greet(how)]] == -1} {
    putlog "GreetWondeR $greet(version) - Configuration Error:"
    putlog "  Variable greet(how) == $greet(how) (Valid: PRIVMSG or NOTICE)"
    return 0
  }
  if {[lsearch -exact [greet:stl $greet(hierarchie)] "nick"] == -1 && [lsearch -exact [greet:stl $greet(hierarchie)] "chan"] == -1 && [lsearch -exact [greet:stl $greet(hierarchie)] "mask"] == -1} {
    putlog "GreetWondeR $greet(version) - Configuration Error:"
    putlog "  Variable greet(hierarchie) == $greet(hierarchie)"
    putlog "  (Valid: nick and/or mask and/or chan)"
    return 0
  }
  if {[lsearch -exact "all known unknown" [greet:stl $greet(who)]] == -1} {
    putlog "GreetWondeR $greet(version) - Configuration Error:"
    putlog "  Variable greet(who) == $greet(who) (Valid: all, kown or unknown)"
    return 0
  }
  if {[lsearch -exact "0 1" $greet(floodprotect)] == -1} {
    putlog "GreetWondeR $greet(version) - Configuration Error:"
    putlog "  Variable greet(floodprotect) == $greet(floodprotect) (Valid: 0 or 1)"
    return 0
  }
  if {[llength [split $greet(flood_join) :]] != 2} {
    putlog "GreetWondeR $greet(version) - Configuration Error:"
    putlog "  Variable greet(flood_join) == $greet(flood_join)"
    putlog "  (Valid: seconds:joins - e.g.: 10:50)"
    return 0
  }
  catch { $footimer; $dftimer }
  if {![file exists $greet(dir)]} {
    exec mkdir $greet(dir)
    exec mkdir $greet(dir)/channels
    foreach chan [greet:getchannels] {
      set cfilename [greet:stl [string trimleft $chan #]]
      set file [open $greet(dir)/channels/${cfilename}.dat w]
      close $file
      set file [open $greet(dir)/channels/${cfilename}.host w]
      close $file
      if {![info exists channels_created]} { set channels_created $chan } { append channels_created ", $chan" }
    }
    greet:createdata
    set file [open $greet(dir)/$greet(nicks) w]
    close $file
    greet:putinit $what $idx "-----------"
    greet:putinit $what $idx "GreetWondeR $greet(version) - Starting Setup Sequence."
    greet:putinit $what $idx " "
    greet:putinit $what $idx "  Created directory: $greet(dir)"
    if {[info exists channels_created]} { 
      if {[llength $channels_created] > 1} {
        greet:putinit $what $idx "  Created channelfiles for: $channels_created"
      } {
        greet:putinit $what $idx "  Created channelfile for: $channels_created"
      }
    }
    greet:putinit $what $idx "  Created datafile: $greet(data)"
    greet:putinit $what $idx "  Created nickfile: $greet(nicks)"
    if {$greet(floodprotect) == 1} {
      greet:putinit $what $idx "  Flood Protection: enabled ([lindex [split $greet(flood_join) :] 0] joins in [lindex [split $greet(flood_join) :] 1] secs)"
    } {
      greet:putinit $what $idx "  Flood Protection: disabled"
    }
    greet:putinit $what $idx " "
    greet:putinit $what $idx "GreetWonder $greet(version) - Setup complete."
    greet:putinit $what $idx "-----------"
  }
  if {![file exists $greet(dir)/$greet(data)]} { greet:createdata }
  set file [open $greet(dir)/$greet(data) r]
  while {![eof $file]} {
    set line [gets $file]
    if {[string match "# TCL: GreetWondeR *" $line]} {
      set olddataver "[lindex $line 3]"
    }
  }
  close $file 
  if {![info exists olddataver]} { set olddataver "" }
  if {"$greet(version)" != "$olddataver"} {
    greet:putinit $what $idx  "-----------"
    greet:putinit $what $idx  "GreetWondeR $greet(version) Starting Update Sequence."
    greet:putinit $what $idx  " "
    greet:putinit $what $idx  "  Updating old GreetWondeR Version $olddataver"
    set file [open $greet(dir)/$greet(data) r]
    while {![eof $file]} {
      set line [gets $file]
      if {![string match "#*" $line]} {
        if {[string match "greethow(+*" $line]} {
	  set line "greethow([string range $line 10 end]"
	}  
        if {[string match "greet(who) =" $line] || [string match "greetall*" $line]} { 
          switch -exact [lindex $line 2] {
            "0" { set line "[lindex $line 0] = known" }
            "1" { set line "[lindex $line 0] = all" }
            "2" { set line "[lindex $line 0] = unkown" }
	  }
	}
        lappend tmp $line
      }
    }
    close $file
    set file [open $greet(dir)/$greet(data) w]
    puts $file "# TCL: GreetWondeR $greet(version)"
    puts $file "# This file was created on [greet:getdate date] at [greet:getdate time]."
    puts $file "# Usage: varname = value"
    puts $file "# If a line starts with '#', it will be ignored (comment)."
    foreach line $tmp { if {$line != ""} { puts $file $line } } 
    close $file
    if {![file exists $greet(dir)/channels]} { exec mkdir $greet(dir)/channels }
    greet:putinit $what $idx " " 
    if {![file exists $greet(dir)/$greet(nicks)]} {
      set file [open $greet(dir)/$greet(nicks) w]
      close $file
    }
    greet:putinit $what $idx  "GreetWondeR $greet(version) - Update complete."
    greet:putinit $what $idx  "-----------"
  }
  if {![file exists $greet(dir)/$greet(data)]} { 
    greet:createdata
  } {
    foreach chan [greet:getchannels] {
      set chan [greet:stl $chan]
      if {[greet:load greet($chan)] == ""} { 
        set greet($chan) [greet:save greet($chan) 1]
      } elseif {[lsearch "0 1" [greet:load greet($chan)]] == -1} {
        set greet($chan) [greet:save greet($chan) 1]
      }
      if {[greet:load greetall($chan)] == ""} { 
        set greetall($chan) [greet:save greetall($chan) $greet(who)]
      } elseif {[lsearch "all known unknown" [greet:load greetall($chan)]] == -1} {
        set greetall($chan) [greet:save greetall($chan) $greet(who)]
      }
      if {[greet:load greethow($chan)] == ""} { 
        set greethow($chan) [greet:save greethow($chan) $greet(how)]
      } elseif {[lsearch "NOTICE PRIVMSG" [greet:load greethow($chan)]] == -1} {
        set greethow($chan) [greet:save greethow($chan) $greet(how)]
      }
      if {[greet:load greetrand($chan)] == ""} {
        set greetrand($chan) [greet:save greetrand($chan) $greet(random)]
      } elseif {[lsearch "on off" [greet:load greetrand($chan)]] == -1} {
        set greetrand($chan) [greet:save greetrand($chan) $greet(random)]
      }
    } 
  }  
  if {![file exists $greet(dir)/channels]} { exec mkdir $greet(dir)/channels } 
  if {![file exists $greet(dir)/$greet(nicks)]} {
    set file [open $greet(dir)/$greet(nicks) w]
    close $file
  }
  foreach chan [greet:getchannels] {
    if {![file exists $greet(dir)/channels/[greet:stl [string trimleft $chan #]].host]} {
      set file [open $greet(dir)/channels/[greet:stl [string trimleft $chan #]].host w]
      close $file
    }
    if {![file exists $greet(dir)/channels/[greet:stl [string trimleft $chan #]].dat]} {
      set file [open $greet(dir)/channels/[greet:stl [string trimleft $chan #]].dat w]
      close $file
    }
  }  
  set file [open $greet(dir)/$greet(data) r]
  while {![eof $file]} {
    set line [gets $file]
    if {[string match "greet(*" $line] || [string match "greetall(*" $line] || [string match "greethow(*" $line] || [string match "greetrand(*" $line]} {
      set [lindex $line 0] "[lindex $line 2]"
    }
  }
  close $file  
  set nickgreets [greet:getfile $greet(dir)/$greet(nicks)]
  foreach chan [greet:getchannels] {
    set changreets([greet:stl $chan]) [greet:getfile $greet(dir)/channels/[greet:stl [string trimleft $chan #]].dat]
    set hostgreets([greet:stl $chan]) [greet:getfile $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host]
  }
  set greet(counter) [greet:load greet(counter)]
  if {$greet(counter) == ""} { set greet(counter) [greet:save greet(counter) 0] }
  set greet(lcount) [greet:load greet(lcount)]
  if {$greet(lcount) == ""} { set greet(lcount) [greet:save greet(lcount) 0] }
  if {$what == "start"} { putlog "GreetWondeR $greet(version) by Wingman loaded (.greethelp for help)." } 
  return 1
} 

if {![greet:init start -]} {return 0}
# --- end: init procs ---

# --- bindings ---
# proc greet:unbinds -> unbinds *all* bindings of greetwonder
# proc greet:binds -> binds all bindings available
proc greet:unbind {} {
  foreach cmd "greetreset greetstatus greet greetmv greetmove greetrandom greethow greetwho greethelp greetinfo +greetnick -greetnick +greet -greet +greetmask -greetmask +greetfile greetnickview greetview greetver greetmotd gmotd" { catch {unbind dcc -|- $cmd [bind dcc -|- $cmd]} } 
  catch { unbind join -|- *!*@* greet:join }
  catch { unbind bot -|- sg_info bot:sginfo }
  catch { unbind bot -|- gw_version gw_version }
  catch { unbind bot -|- sg_version gw_version }
  catch { unbind chon n|- * motd:greet }
  catch { unbind raw -|- 421 raw:greetfoo }
}

proc greet:bind {} {
  global greet
  bind dcc $greet(gbind) greetreset dcc:greetreset
  bind dcc $greet(gbind) greetstatus dcc:greetstatus
  bind dcc $greet(gbind) greetver dcc:getgwv
  bind dcc $greet(nbind) greet dcc:greet
  bind dcc $greet(rbind) greetmove dcc:greetmove
  bind dcc $greet(rbind) greetmv dcc:greetmove
  bind dcc $greet(rbind) greetrandom dcc:greetrandom
  bind dcc $greet(rbind) greethow dcc:greethow
  bind dcc $greet(rbind) greetwho dcc:greetwho
  bind dcc $greet(rbind) greethelp dcc:greethelp
  bind dcc $greet(rbind) greetinfo dcc:greetinfo
  bind splt -|- * greet:splt
  bind rejn -|- * greet:rejn
  bind bot -|- gw_version gw_version
  bind bot -|- sg_version gw_version
  bind bot -|- sg_info bot:sginfo
  bind raw -|- 421 raw:greetfoo
  if {[lsearch -exact "[string tolower $greet(hierarchie)]" nick] != -1} {
    bind dcc $greet(nbind) +greetnick dcc:+greetnick
    bind dcc $greet(nbind) -greetnick dcc:-greetnick
    bind dcc $greet(nbind) greetnickview dcc:greetnickview
  }
  if {[lsearch -exact "[string tolower $greet(hierarchie)]" chan] != -1} {
    bind dcc $greet(gbind) +greetfile dcc:+greetfile
    bind dcc $greet(rbind) +greet dcc:+greet
    bind dcc $greet(rbind) -greet dcc:-greet
  }
  if {[lsearch -exact "[string tolower $greet(hierarchie)]" mask] != -1} {
    bind dcc $greet(rbind) +greetmask dcc:+greetmask
    bind dcc $greet(rbind) -greetmask dcc:-greetmask
  } 
  if {[lsearch -exact "[string tolower $greet(hierarchie)]" mask] != -1 || [lsearch -exact "[string tolower $greet(hierarchie)]" chan] != -1} {
    bind dcc $greet(rbind) greetview dcc:greetview
  }
  return
}

greet:unbind ; greet:bind
# --- end: bindings ---

# --- commands (dcc, etc) ---
# dcc:+greet
# dcc:-greet
# dcc:+greetmask
# dcc:-greetmask
# dcc:+greetfile
# dcc:+greetnick
# dcc:-greetnick
# dcc:greethow
# dcc:greetwho
# dcc:greet
# dcc:greethelp
# dcc:greetstatus
# dcc:greetreset
# dcc:greetview

proc dcc:greetreset { handle idx arg } {
  global greet
  putcmdlog "#$handle# greetreset"
  putdcc $idx "Resetting GreetWondeR $greet(version)" 
  if {[file exists $greet(dir)]} {exec rm -rf $greet(dir)}
  greet:init reset $idx 
  putdcc $idx "All done. GreetWondeR $greet(version) successfully reseted."
  return 0 
}

proc dcc:greetstatus { handle idx arg } {
  global greet
  global nickgreets
  global greetflood grqueue gqueue
  global footimer dftimer
  greet:refresh
  if {[string match "./*" $greet(dir)]} { set dir [string range "$greet(dir)" 2 [string length $greet(dir)]] } { set dir $greet(dir) }
  set file [open $greet(dir)/$greet(data) r]
  set varcount 0
  while {![eof $file]} {
    set line [gets $file]
    if {[llength $line] > 1 && ![string match "#*" $line]} { incr varcount }
  }
  close $file 
  set file [open $greet(dir)/$greet(nicks) r]
  set nickcount 0
  while {![eof $file]} {
    set line [gets $file]
    if {[llength $line] > 1 && ![string match "#*" $line]} { incr nickcount }
  }
  close $file
  if {![info exists chanlcount]} { set chanlcount 0 }
  if {![info exists chancount]} { set chancount 0 }
  foreach type "dat host" {
    foreach file [glob $dir/channels/*.$type] {
      set file [open $file r]
      while {![eof $file]} {
        set line [gets $file]
        if {$line != ""} {
          incr chanlcount
          set chancount [expr [string length $line] + $chancount]
        }
      }
      close $file
    }
  }  
  putcmdlog "#$handle# greetstatus $arg"
  putdcc $idx "I'm GreetWondeR, running Version $greet(version), released on $greet(rdate)."
  set boo ""
  putdcc $idx " "
  if {$arg == "all"} {
    set boo "  "
    putdcc $idx " FILE SETTINGS:"
    putdcc $idx "  Saving greets:     [pwd]/$dir/"
    putdcc $idx "  Saving data:       [pwd]/$dir/$greet(data) ($varcount vars/[file size $greet(dir)/$greet(data)] bytes)"
    putdcc $idx "  Saving nickgreets: [pwd]/$dir/$greet(nicks) ($nickcount greets/[file size $greet(dir)/$greet(nicks)] bytes)" 
    putdcc $idx "  Saving changreets: [pwd]/$dir/channels/ ($chanlcount greets/$chancount bytes)"
    putdcc $idx " "
  }
  if {$arg == "all"} {putdcc $idx " DEFAULT SETTINGS:"} 
  putdcc $idx "${boo}Greeting users:        [greet:stl $greet(who)]"
  putdcc $idx "${boo}How to greet:          [greet:stl $greet(how)]"
  putdcc $idx "${boo}Random greets:         [greet:stl $greet(random)]"
  putdcc $idx "${boo}Flag greet seperation: [greet:stl $greet(flag_greet_seperation)]"
  if {$greet(max) == 0} {
    putdcc $idx "${boo}Greet limitation:      none"
  } {
    putdcc $idx "${boo}Greet limitation:      $greet(max) lines"
  }
  for {set i 0} {$i <= [expr [llength $greet(hierarchie)] -1]} {incr i} {
    if {![info exists greeth]} {
      set greeth "[lindex $greet(hierarchie) $i]greets" 
    } {
      append greeth ", [lindex $greet(hierarchie) $i]greets"
    }
  }  
  for {set i 0} {$i <= [expr [llength [split $greet(sorted) ""]] -1]} {incr i} {
    if {![info exists fhier]} {
      set fhier "+[lindex [split $greet(sorted) ""] $i]"
    } {
      if {$i == [expr [llength [split $greet(sorted) ""]] -1]} {
        append fhier " and last +[lindex [split $greet(sorted) ""] $i]"
      } {
        append fhier ", +[lindex [split $greet(sorted) ""] $i]" 
      }
    }
  }  
# " <- vim's syntax got crazy with the lines above...so i had to add this line
  putdcc $idx "${boo}Flaghierarchie:        $fhier"
  if {[llength $greet(hierarchie)] != 3} {
    foreach var "nick chan mask" {
      if {[lsearch -exact "$greet(hierarchie)" $var] == -1} {
        if {![info exists disgreet]} { 
          set disgreet "${var}greets"
        } {
          append disgreet ", ${var}greets"
	}
      } 
    }	
  }
  if {[info exists disgreet]} {
    putdcc $idx "${boo}Greethierarchie:       $greeth (disabled: $disgreet)"
  } {
    putdcc $idx "${boo}Greethierarchie:       $greeth"
  }
  set cl [greet:sl [channels]]
  if {$greet(floodprotect) == 1 && $arg == "all"} {
    putdcc $idx " "
    putdcc $idx " FLOOD SETTINGS:"
    putdcc $idx "  Flood joins are:   [lindex [split $greet(flood_join) :] 0] joins in [lindex [split $greet(flood_join) :] 1] secs"
    putdcc $idx "  Shutdown for:      $greet(noresponse) mins"
  }
  if {$arg == "all"} {
    putdcc $idx " "
    putdcc $idx " QUEUE SETTINGS:"
    if {[info exists dftimer] || [info exists footimer]} {
      putdcc $idx "  QSTUFF patch:      Yes (GreetWondeR Queue System is offline)"
    } {
      if {![info exists grqueue]} { set grqueue "" }
      if {([lindex [split $greet(sendq) :] 0] == 0) || ([lindex [split $greet(sendq) :] 1] == 0) || $greet(sendc) == 0} {
        putdcc $idx "  Queue settings:    using eggdrop queue system"
      } {
        putdcc $idx "  Queue settings:    [lindex [split $greet(sendq) :] 0] bytes in [lindex [split $greet(sendq) :] 1] secs (currently: [string length $grqueue] bytes)"
        putdcc $idx "                     or $greet(sendc) cmds in [lindex [split $greet(sendq) :] 1] secs (currently: [llength $grqueue] cmds)"
        putdcc $idx "  Maximalqueue:      $greet(maxqueue) bytes"
        putdcc $idx "  QSTUFF patch:      No (try '.greethelp qstuff')" 
        if {![info exists greet(counter)]} { 
          set greet(counter) [greet:load greet(counter)]
          if {$greet(counter) == ""} { set greet(counter) 0 }
        }
        if {![info exists greet(lcount)]}  {
          set greet(lcount) [greet:load greet(lcount)]
          if {$greet(lcount) == ""} { set greet(lcount) 0 }
        }
        if {$greet(lcount) == 0 || $greet(counter) == 0} {
          set perc 0
        } {
          set perc [expr [expr $greet(lcount) * 100]/$greet(counter)]
        }
        putdcc $idx "  Statistics:        skipped $perc % of greets (total: $greet(lcount)/$greet(counter))"
      }
    }
    putdcc $idx " "
  }
  set count 0
  if {$arg == "all"} { putdcc $idx " GREETS:" }
  putdcc $idx " " 
  putdcc $idx "${boo}Nickgreets:        There are $nickcount greets saved."
  putdcc $idx " "
  if {$cl <= 9} { set cl 10 }  
  putdcc $idx "${boo}[format "%-${cl}s | %-8s | %-5s | %-5s | %-6s | %-6s" Channel Who Lines Hosts On/Off Random]"
  for {set foo 1} {$foo <= [expr ${cl} + 45]} {incr foo} {append goo "-"}
  putdcc $idx "${boo}$goo" 
  foreach chan [channels] {
    set chan [greet:stl $chan]
    set greetload "$greet(dir)/channels/[greet:stl [string trimleft $chan #]].dat"
    if {![file exists $greetload]} {
      set file [open $greetload w]
      close $file
    }
  set count 0
  set file [open $greetload r]
  while {![eof $file]} {
    set line [gets $file]
    if {$line != ""} {
      incr count
    }
  }
  close $file
  set greetall [greet:load greetall([greet:stl $chan])]
  if {[greet:load greet([greet:stl $chan])] == 1} {set b "on"} {set b "off"}
  set hcount 0
  set hfile [greet:getfile $greet(dir)/channels/[greet:stl [string trimleft $chan #]].host]
  set rand [greet:load greetrand([greet:stl $chan])]
  if {$rand == ""} { set rand "off" ; greet:save greetrand([greet:stl $chan]) off }
  foreach line $hfile { incr hcount }
  if {$count == 0 && $hcount == 0} {
    if {![info exists tmp1]} { set tmp1 "$chan" } { append tmp1 ", $chan" }
  } {
    putdcc $idx "${boo}[format "%-${cl}s | %-8s | %-5s | %-5s | %-6s | %-6s" $chan $greetall $count $hcount $b $rand]"
    if {[info exists greetflood([greet:stl $chan])]} {
      putdcc $idx "${boo} WARNING: There were FLOOD JOINS on $chan: Greets are disabled."
      }
    }
  }
  if {[info exists tmp1]} {
    if {[llength $tmp1] == [llength [greet:getchannels]]} {
      putdcc $idx "${boo}There are currently no Chan- or Maskgreets saved."
    } {
      putdcc $idx " "
      if {[llength $tmp1] > 1} {
        putdcc $idx "${boo}Channels with no Chan- or Maskgreets: $tmp1"
      } {
        putdcc $idx "${boo}Channel with no Chan- or Maskgreets: $tmp1"
      }
    }
  }
  if {$arg != "all"} { putdcc $idx " "; putdcc $idx "Try '.greetstatus all' for more information." }
  return 0
}

proc dcc:greetinfo { handle idx arg } {
  global greet
  putcmdlog "#$handle# greetinfo $arg"
  putdcc $idx "GreetWondeR $greet(version) (Eggdrop 1.x Greet TCL Script)"
  putdcc $idx "---------------"
  putdcc $idx "Released: $greet(rdate)"
  putdcc $idx "Author: Wingman <Wingman@WINGDesign.de>"
  putdcc $idx "        http://www.WINGDesign.de/"
  putdcc $idx "GreetWondeR Homepage: http://www.WINGDesign.de/greetwonder/"
  putdcc $idx "You can contact me on IRCNet at #Quake2.GER, #Star_Trek and #Muenchen."
  putdcc $idx "---------------"
}

proc dcc:+greetnick { handle idx arg } {
  global greet 
  global nickgreets
  if {[llength $arg] < 3} {
    putdcc $idx "Usage: .+greetnick <handle> <msg/notice/pub/act> <text>"
    return 0
  }
  set nick [lindex $arg 0]
  set how [greet:stl [lindex $arg 1]]
  switch -exact $how {
    "msg"    { set how "PRIVMSG" ; set tmp 1 }
    "notice" { set how "NOTICE " ; set tmp 1 }
    "pub"    { set how "PUBLIC"  ; set tmp 1 }
    "act"    { set how "ACTION"  ; set tmp 1 }
    }
  if {[lsearch -exact "PRIVMSG NOTICE PUBLIC ACTION" $how] == -1} { 
    putdcc $idx "ERROR: Don't know, how to greet via $how."
    return 0
  }
  set text [greet:lend 2 $arg]
  if {![validuser $nick]} {
    putdcc $idx "I don`t know $nick. Only nicks, which are in the userlist, are allowed!"
    return 0
  }  
  if {$text == ""} {
    putdcc $idx "Usage: .+greetnick <handle> <msg/notice/pub/act> <text>"
    return 0
  }
  if {![file exists $greet(dir)/$greet(nicks)]} {
    set file [open $greet(dir)/$greet(nicks) w]
    puts $file "$nick $how $text"
    close $file
  } {
    set fileindex [greet:getfile $greet(dir)/$greet(nicks)]
    foreach line $fileindex {  
      if {[llength $line] > 1} {
        if {[string match [greet:stl "$nick"] [greet:stl [lindex $line 0]]]} {
          putdcc $idx "Already a greetline for $nick: [greet:lend 2 $line] via [lindex $line 1]"
          return 0
	}
      }
    }
    set file [open $greet(dir)/$greet(nicks) a+]
    puts $file "$nick $how $text"
    close $file
  }
  set nickgreets [greet:getfile $greet(dir)/$greet(nicks)]
  putcmdlog "#$handle# +greetnick $nick ($how) $text"
  putdcc $idx "Now greeting $nick with \"$text\" via $how."
  return 0 
}

proc dcc:-greetnick { handle idx arg } {
  global greet
  global nickgreets
  if {[llength $arg] < 1} {
    putdcc $idx "Usage: .-greetnick <handle>"
    return 0
  }
  set nick [lindex $arg 0]
  if {![validuser $nick]} {
    putdcc $idx "I don`t know $nick. Only nicks, which are in the userlist, are allowed."
    return 0
  }
  if {![file exists $greet(dir)/$greet(nicks)]} {
    putdcc $idx "No nick greets are saved."
    return 0
  }
  set tmp [greet:getfile $greet(dir)/$greet(nicks)]
  set file [open $greet(dir)/$greet(nicks) w]
  foreach line $tmp {
    if {$line != ""} {
      if {![string match [greet:stl "$nick *"] [greet:stl $line]]} {
        puts $file $line
      } {
        set found 1
      }
    }
  }
  close $file
  set nickgreets [greet:getfile $greet(dir)/$greet(nicks)]
  if {![info exists found]} {
    putdcc $idx "Can't find any greet for $nick."
  } {
    putdcc $idx "Deleted greet for $nick."
  }
  putcmdlog "#$handle# -greetnick $nick"
  return 0 
}

proc dcc:greethelp { handle idx arg } {
  global greet
  global files-path
  set arg "[greet:stl $arg]"
  set gflag1 [greet:flag2norm [lindex [split $greet(gbind) |] 0]]
  set cflag1 [greet:flag2norm [lindex [split $greet(gbind) |] 1]]
  set gflag2 [greet:flag2norm [lindex [split $greet(nbind) |] 0]]
  set cflag2 [greet:flag2norm [lindex [split $greet(nbind) |] 1]]
  set gflag3 [greet:flag2norm [lindex [split $greet(rbind) |] 0]]
  set cflag3 [greet:flag2norm [lindex [split $greet(rbind) |] 1]]
  putcmdlog "#$handle# greethelp $arg"
  if {[llength $arg] < 1} {
    putdcc $idx "DCC COMMANDS for GreetWondeR $greet(version)"
    putdcc $idx " "
    if {[greet:matchattr $handle $greet(gbind) ""]} {
      if {"$cflag1" == "-"} {
        putdcc $idx "  For global $gflag1:"
      } {
        putdcc $idx "  For global $gflag1 and chan$cflag1:"
      }	
      if {![info exists files-path]} {
        putdcc $idx "    greetreset     greetstatus       greetver"
      } { 
        putdcc $idx "    +greetfile     greetreset        greetstatus"
        putdcc $idx "    greetver"      
      }	
      putdcc $idx " "
    }  
    if {[greet:matchattr $handle $greet(nbind) ""]} {
      if {"$cflag2" == "-"} {
        putdcc $idx "  For global $gflag2:"
      } {
        putdcc $idx "  For global $gflag2 and chan$cflag2:"
      }
      if {[lsearch -exact "nick" $greet(hierarchie)] != -1} {
        putdcc $idx "    greet"
      } {
        putdcc $idx "    +greetnick     greetnickview     greet"
        putdcc $idx "    -greetnick"
      }
      putdcc $idx " "
    }  
    if {"$cflag3" == "-"} {
      putdcc $idx "  For global $gflag3:"
    } {
      putdcc $idx "  For global $gflag3 and chan$cflag3:"
    }
    if {[lsearch -exact "mask" $greet(hierarchie)] != -1} {
      putdcc $idx "    +greet            greetmove        greetview"
      putdcc $idx "    -greet            greetrandom      greetwho"
      putdcc $idx "    greethow          greetinfo"
    } {
      putdcc $idx "    +greet         +greetmask        greetwho"
      putdcc $idx "    -greet         -greetmask        greethow"
      putdcc $idx "    greetmove      greetview         greetrandom"
      putdcc $idx "    greetinfo"
    }
    putdcc $idx " "
    putdcc $idx "If you want a short introduction to this tcl, use '.greethelp guide'"
    putdcc $idx "You can get help on individual commands: '.greethelp <command>'"
    return 0
  }
  if {$arg ==  "greetreset"} {
    putdcc $idx "### greetreset"
    putdcc $idx "    Removes _all_ files created by GreetWondeR and then restarts the script."
    putdcc $idx "    WARNING: All greets will be lost after a .greetreset!"
    return 0
  }
  if {$arg ==  "+greetnick"} {
    putdcc $idx "### +greetnick <handle> <msg/notice/pub> <text>"
    putdcc $idx "   Adds a greet (<text>) for <handle>."
    putdcc $idx "   Only known nicks (userlist) are allowed."
    putdcc $idx "   NOTE: Only 1 line is allowed."
    putdcc $idx " "
    putdcc $idx "   Example:"
    putdcc $idx "   .+greetnick Wingman msg Hi Wing, what's up?"
    return 0
  }
  if {$arg ==  "-greetnick"} {
    putdcc $idx "### -greetnick <handle>"
    putdcc $idx "   Deletes the greet for <handle>."
    putdcc $idx " "
    putdcc $idx "   Example:"
    putdcc $idx "   .-greetnick Wingman"
    return 0
  }
  if {$arg ==  "greetnickview"} {
    putdcc $idx "### greetnickview"
    putdcc $idx "   Shows Nickgreets."
    return 0
  }
  if {$arg ==  "+greet"} {
    putdcc $idx "### +greet \[channel\] \[+flag\] <text>"
    putdcc $idx "   Adds a greetline for \[channel\]."
    putdcc $idx "   greet-nick, greet-chan and greet-botnick are replaced by the"
    putdcc $idx "   proc vars:"
    putdcc $idx "   if Wingman joins #Eggdrop, he will see instead of greet-nick"
    putdcc $idx "   and greet-chan - Wingman and #Eggdrop."
    putdcc $idx " "
    putdcc $idx "   Example:"
    putdcc $idx "   .+greet Welcome greet-nick to greet-chan!"
    putdcc $idx "   .+greet #eggdrop Welcome greet-nick to greet-chan"
    putdcc $idx "   .+greet +n Welcome, you are a owner of this chan"
    putdcc $idx " "
    putdcc $idx "See also: -greet, greetview"
    return 0
  }
  if {$arg ==  "-greet"} {
    putdcc $idx "### -greet \[channel\] \[+flag\] <linenr>"
    putdcc $idx "   Deletes line <linenr> from \[channel\]."
    putdcc $idx " "
    putdcc $idx "   Example:"
    putdcc $idx "   .-greet 1"
    putdcc $idx "   .-greet #eggdrop 2"
    putdcc $idx "   .-greet +n 3"
    putdcc $idx " "
    putdcc $idx "See also: +greet, greetview"
    return 0
  }
  if {$arg ==  "greetview"} {
    putdcc $idx "### greetview \[channel\]"
    putdcc $idx "   Shows the greets for \[channel\]."
    putdcc $idx " "
    putdcc $idx "   Example:"
    putdcc $idx "   .greetview"
    putdcc $idx "   .greetview #eggdrop"
    putdcc $idx "See also: +greet, -greet"
    return 0
  }
  if {$arg ==  "greet"} {
    putdcc $idx "### greet \[channel\] <on/off>"
    putdcc $idx "   Enables/disables greets for \[channel\]."
    putdcc $idx " "
    putdcc $idx "   Example:"
    putdcc $idx "   .greet on"
    putdcc $idx "   .greet #eggdrop on"
    putdcc $idx "See also: greetwho, greethow, greetview"
    return 0
  }
  if {$arg ==  "greetwho"} {
    putdcc $idx "### greetwho \[channel\] <all/known/unknown>"
    putdcc $idx "   Show greets to all, only known users or"
    putdcc $idx "   only unknown users?"
    putdcc $idx " "
    putdcc $idx "   Example:"
    putdcc $idx "   .greetwho all"
    putdcc $idx "   .greetwho #eggdrop all"
    putdcc $idx "See also: greet, greethow, greetview"
    return 0
  }
  if {$arg ==  "greethow"} {
    putdcc $idx "### greethow \[channel\] \[+flag\] <notice/privmsg>"
    putdcc $idx "   Should i greet users via NOTICE or PRIVMSG (MSG)?"
    putdcc $idx " "
    putdcc $idx "   Example:"
    putdcc $idx "   .greethow notice"
    putdcc $idx "   .greethow #eggdrop msg"
    putdcc $idx "See also: greet, greetwho, greetview"
    return 0
  }
  if {$arg == "greetinfo"} {
    putdcc $idx "### greetinfo"
    putdcc $idx "   Shows some Informations about this tcl and its coder."
    return 0
  }  
  if {$arg ==  "guide"} {
    putdcc $idx "A short guide for GreetWondeR $greet(version)"
    putdcc $idx "1. If you want to add a greet for #test, which should get all users:"
    putdcc $idx "   .+greet #test Hi greet-nick - Welcome to greet-chan!"
    putdcc $idx "   .greetwho #test all"
    putdcc $idx " "
    putdcc $idx "2. If you want flag specific greets, try:"
    putdcc $idx "   .+greet #test +n Hi greet-nick - You are an Owner on greet-chan!" 
    putdcc $idx " "
    putdcc $idx "3. If you want to greet a nick with a specific line, then use:"
    putdcc $idx "   .+greetnick Nickname pub Hi Nick, what's up?"
    putdcc $idx "   (Only nicknames, which are in the userlist are allowed)"
    putdcc $idx " "
    putdcc $idx "4. A feature of this tcl is its varreplacing:"
    putdcc $idx "   greet-nick, greet-chan and greet-botnick are replaced by the tcl vars,"
    putdcc $idx "   which means, if let's say Wingman joins #Eggdrop and the Botnick"
    putdcc $idx "   is Eggie, he will see (if there's greet like:"
    putdcc $idx "   Hi greet-nick! Welcome to greet-chan - For a help try /msg greet-botnick help"
    putdcc $idx "   Hi Wingman! Welcome to #Eggdrop - For a help try /msg Eggie help"
    putdcc $idx " "
    if {$greet(max) != 0} {
      putdcc $idx "HINT: You can add up to $greet(max) lines for a greet, but just 1 line for a nickgreet."
    }
    return 0
  }
  if {$arg ==  "+greetfile"} {
    putdcc $idx "### .+greetfile \[channel] \[+flag\] <filename>"
    putdcc $idx "   Imports greets from a file."
    putdcc $idx " "
    putdcc $idx "   Examples:"
    putdcc $idx "   .+greetfile #channel motd"
    putdcc $idx "   .+greetfile +n incoming/ngreets.dat"
    putdcc $idx "See also: +greet, +greethost"
    return 0
  }
  if {$arg ==  "+greetmask"} {
    putdcc $idx "### .+greetmask \[channel\] <nick!ident@host> <greet>"
    putdcc $idx "   Adds <greet> for <nick!ident@host>. Wildcards are allowed."
    putdcc $idx " "
    putdcc $idx "   Examples:"
    putdcc $idx "   .+greetmask #eggdrop *fuck*!*@* Please change your nickname!"
    putdcc $idx "   .+greetmask #eggdrop *!*@*.de Hi greet-nick, bitte sprich nur Englisch in greet-chan!"
    putdcc $idx "See also: -greetmask, greetview"
    return 0
  }
  if {$arg ==  "-greetmask"} {
    putdcc $idx "### .-greetmask \[channel\] <nick!ident@host> <linenr>"
    putdcc $idx "    .-greetmask \[channel\] <all>"
    putdcc $idx "   Deletes line <linenr> for <nick!ident@host>."
    putdcc $idx " "
    putdcc $idx "   Examples:"
    putdcc $idx "   .-greetmask #eggdrop *fuck*!*@* 1"
    return 0
  }
  if {$arg ==  "greetmove"} { 
    putdcc $idx "### greetmove \[channel\] \[+flag\] <from> <to>"
    putdcc $idx "   Moves a line from line number <from> to line number <to>."
    putdcc $idx " "
    putdcc $idx "   Example:"
    putdcc $idx "   .greetmove #channel 1 3"
    putdcc $idx "   .greetmove +n 2 4"
    return 0
  }
  if {$arg ==  "greetrandom"} {
    putdcc $idx "### .greetrandom \[channel\] \[+flag\] <on/off>"
    putdcc $idx "   Turns on or off random greets on \[channel\] (for \[+flag\] users)"
    putdcc $idx " "
    putdcc $idx "   Examples:"
    putdcc $idx "   .greetrandom on"
    putdcc $idx "   .greetrandom #channel +n o"
    return 0
  }
  if {$arg == "greetver"} {
    putdcc $idx "### .greetver"
    putdcc $idx "   Shows all bots on the botnet with GreetWondeR installed."
    return 0
  }
  if {$arg == "qstuff"} {
    putdcc $idx "### QSTUFF (Eggdrop 1.3.28+ Patch) - (c) G`Quann 1999 <eggfan@3dart.de>"
    putdcc $idx "   QSTUFF is an eggdrop 1.3.28+ patch, which recodes the internal "
    putdcc $idx "   queue system. It's based on a very _simple_ method and protects"
    putdcc $idx "   your eggdrop from being excess flooded. I've tested it on my own"
    putdcc $idx "   and it worked perfectly. No one was able to flood my bot off the server."
    putdcc $idx "   Visit http://www.WINGDesign.de/greetwonder for more information."
    return 0
  }
  putdcc $idx "No help available on that."
  return 0 
}

proc dcc:greetrandom { handle idx arg } {
  global greet
  global greetrand
  if {[llength $arg] < 1} {
    putdcc $idx "Usage: .greetrandom \[channel\] \[+flag\] <on/off>"
    return 0
  }
  if {[string match "#*" [lindex $arg 0]]} {
    if {[string match "+*" [lindex $arg 1]]} {
      if {[llength $arg] < 3} {
        putdcc $idx "Usage: .greetrandom \[channel\] \[+flag\] <on/off>"
        return 0
      }
      set greetchan [lindex $arg 0]
      set greetflag [lindex $arg 1]
      set greetwhat [lindex $arg 2]
    } {
      set greetchan [lindex $arg 0]
      if {[llength $arg] < 2} {
        putdcc $idx "Usage: .greetrandom \[channel\] \[+flag\] <on/off>"
        return 0
      }
      set greetwhat [lindex $arg 1]
    }
  } {
    if {[string match "+*" [lindex $arg 0]]} {
      set greetflag [lindex $arg 0]
      if {[llength $arg] < 2} {
        putdcc $idx "Usage: .greetrandom \[channel\] \[+flag\] <on/off>"
        return 0
      }
      set greetwhat [lindex $arg 1]
    } {
      set greetwhat [lindex $arg 0]
    }
    set greetchan [lindex [console $idx] 0]
  }
  if {[info exists greetflag] && [string length $greetflag] > 2} {
    putdcc $idx "Only 1 flag is allowed, e.g. .greetrandom +n on"
    return 0
  }
  if {[info exists greetflag] && [lsearch -exact [split "abcdefghijklmnopqrstuvwxyz1234567890" ""] [greet:stl [string trimleft $greetflag +]]] == -1} {
    putdcc $idx "$greetflag is no valid flag."
    return 0
  }
  if {$greetchan == "*"} {
    putdcc $idx "Your console channel is invalid."
    return 0
  }
  if {![validchan $greetchan]} {
    putdcc $idx "I'm not on $greetchan."
    return 0
  }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""] && ![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $greetchan]} {
    putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $greetchan."
    return 0
  }
  if {[greet:stl $greetwhat] != "on" && [greet:stl $greetwhat] != "off"} {
    putdcc $idx "Usage: .greetrandom \[channel\] \[+flag\] <on/off>"
    return 0
  }
  if {[info exists greetflag]} {
    putcmdlog "#$handle# greetrandom ($greetchan) ($greetflag) $greetwhat"
    set greetrand($greetflag-[greet:stl $greetchan]) $greetwhat
    greet:save greetrand($greetflag-[greet:stl $greetchan]) $greetwhat
    putdcc $idx "Random greets on $greetchan for $greetflag users are now \"[string toupper $greetwhat]\"."
  } {
    putcmdlog "#$handle# greetrandom ($greetchan) $greetwhat"
    set greetrand([greet:stl $greetchan]) $greetwhat
    greet:save greetrand([greet:stl $greetchan]) $greetwhat
    putdcc $idx "Random greets on $greetchan are now \"[string toupper $greetwhat]\"."
  }
  return 0
}

proc dcc:greetmove { handle idx arg } {
  global greet 
  global changreets
  if {[llength $arg] < 1} {
    putdcc $idx "Usage: .greetmove \[channel\] \[+flag\] <from> <to>"
    return 0
  }
  if {[llength $arg] < 2} {
    if {[string match "#*" $arg]} {
      putdcc $idx "Usage: .greetmove \[channel\] \[+flag\] <from> <to>"
      return 0
    }
  }
  set greetflags ""
  if {[string match "#*" $arg]} {
    if {[string match "+*" [lindex $arg 1]]} {
      set to [lindex $arg 3]
      set from [lindex $arg 2]
      set greetflags [lindex $arg 1]
      set greetchan [lindex $arg 0]
    } {
      set to [lindex $arg 2]
      set from [lindex $arg 1]
      set greetchan [lindex $arg 0]
    }
    if {![validchan $greetchan]} {
      putdcc $idx "ERROR: I'm not on $greetchan"
      return 0
    }
  } {
    if {[string match "+*" [lindex $arg 0]]} {
      set from [lindex $arg 1]
      set to [lindex $arg 2]
      set greetflags [lindex $arg 0]
      set greetchan [lindex [console $idx] 0]
    } {
      set from [lindex $arg 0]
      set to [lindex $arg 1]
      set greetchan [lindex [console $idx] 0]
    }
  }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""]} {
    if {![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $greetchan]} {
      putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $greetchan"
      return 0
    }
  }
  if {[string length $greetflags] > 2} {
    putdcc $idx "ERROR: only 1 flag is allowed, e.g. .greetmove +n <from> <to>"
    return 0
  }
  if {$greetchan == "*"} {
    putdcc $idx "Your console channel is invalid."
    return 0
  }
  if {$from == "" || $to == ""} {
    putdcc $idx "Usage: .greetmove \[channel\] \[+flag\] <from> <to>"
    return 0
  }
  if {$greetflags != ""} {
    set validflags "abcdefghijklmnopqrstuvwxyz1234567890"
    if {[lsearch -exact [split $validflags ""] [greet:stl [string trimleft $greetflags +]]] == -1} {
      putdcc $idx "ERROR: $greetflags is no valid flag."
      return 0
    }
  }
  set tmp [greet:getfile $greet(dir)/channels/[greet:stl [string trimleft $greetchan #]].dat]
  set count 0
  if {$greetflags == ""} { 
    foreach line $tmp { if {![string match "+? *" $line]} { if {$line != ""} { incr count } } }
  } {
    foreach line $tmp { if {[string match "$greetflags *" $line]} { if {$line != ""} { if {[string match "$greetflags *" $line]} { incr count } } } } } 
if {$from > $count || $to > $count} {
    putdcc $idx "Error: Only $count lines on $greetchan."
    return 0
  }
  if {$from == 0 || $to == 0} {
    putdcc $idx "Can't move from or to 0!"
    return 0
  }
  if {$from == $to} {
    putdcc $idx "Yeah - moving from one point to the same rulezzz ;)"
    putdcc $idx "I think, you need (psychiatric) .help :))"
    return 0
  }
  set countf 0
  if {$greetflags == ""} {
    foreach line $tmp {
      if {![string match "+*" $line]} {
        incr countf
        if {$countf != $from} { lappend tmp2 $line } { set insert $line }
      }
    }
  } {
    foreach line $tmp {
      if {[string match "$greetflags *" $line]} {
        incr countf
        if {$countf != $from} { lappend tmp2 $line } { set insert $line }
      }
    }
  }
  if {![info exists insert]} {
    putdcc $idx "Error: Can't move from $from."
    return 0
  }
  set countf 0
  set counts [expr $to - 1] 
  if {$greetflags == ""} {
    foreach line $tmp2 {
      if {![string match "+? *" $line]} {
        incr countf
        if {$from < $to} {
          lappend tmp3 $line
          if {$countf == $counts} { lappend tmp3 $insert }
        } {  
          if {$countf == $to} { lappend tmp3 $insert }
          lappend tmp3 $line 
	}
      }
    }
  } {
    foreach line $tmp2 {
      if {[string match "$greetflags *" $line]} {
        incr countf
        if {$countf == $to} { lappend tmp3 $insert }
        lappend tmp3 $line
      }
    }
  }
  set tmp [greet:getfile $greet(dir)/channels/[greet:stl [string trimleft $greetchan #]].dat]
  if {$greetflags == ""} {
    foreach line $tmp { if {[string match "+*" $line]} { lappend newfile $line } }
  } {
    foreach line $tmp { if {![string match "$greetflags *" $line]} { lappend newfile $line } }
  }
  set file [open $greet(dir)/channels/[greet:stl [string trimleft $greetchan #]].dat w]
  if {[info exists newfile]} { foreach line $newfile { puts $file $line } }
  foreach line $tmp3 { puts $file $line }
  close $file
  if {$greetflags == ""} {
    putcmdlog "#$handle# greetmove ($greetchan) $from -> $to"
    putdcc $idx "Moved line $from to line $to on $greetchan."
  } {
    putcmdlog "#$handle# greetmove ($greetchan) ($greetflags) $from -> $to"
    putdcc $idx "Moved line $from to line $to for $greetflags users on $greetchan."
  }
  set changreets([greet:stl $greetchan]) [greet:getfile $greet(dir)/channels/[greet:stl [string trimleft $greetchan #]].dat]  
  return 0 
}

proc dcc:greetnickview { handle idx arg } {
  global greet 
  global nickgreets
  putcmdlog "#$handle# greetnickview"
  putdcc $idx "DISPLAYING NICK-GREETS:"
  putdcc $idx " "
  set nickgreets [greet:getfile $greet(dir)/$greet(nicks)]
  if {$nickgreets == ""} {
    putdcc $idx "There are currently no nick-greets saved."
    putdcc $idx "(use .+greetnick <handle> <msg/notice/pub/act> <text>)"
  } {
    set count 0
    putdcc $idx "   [format "%-9s %-6s" Nick How]   Greet"
    foreach line $nickgreets {
      putdcc $idx "[incr count]: [format "%-9s %-6s" [lindex $line 0] [lindex $line 1]]   [greet:lend 2 $line]"
    }
  }  
  return 0 
}
 
proc dcc:greet { handle idx arg } {
  global greet
  if {[llength $arg] < 1} {
    putdcc $idx "Usage: .greet \[channel\] <on/off>"
    return 0
  }
  set greetchan ""
  set greetwhat ""
  set greetflags ""
  if {[string match "#*" $arg]} {
    set greetchan [greet:stl [lindex $arg 0]]
    set greetwhat [greet:lend 1 $arg]
    if {![validchan $greetchan]} {
      putdcc $idx "ERROR: I'm not on $greetchan"
      return 0
    }
  } {
    set greetwhat [greet:stl $arg]
    set greetchan [greet:stl [lindex [console $idx] 0]]
  }
  if {$greetchan == "*"} {
    putdcc $idx "Your console channel is invalid."
    return 0
  }
  if {$greetwhat == "on"} {
    putcmdlog "#$handle# greet ($greetchan) on"
    greet:save greet($greetchan) 1
    set greet($greetchan) 1
    putdcc $idx "Greets for $greetchan are now enabled."
    return 0
  }
  if {$greetwhat == "off"} {
    putcmdlog "#$handle# greet ($greetchan) off"
    greet:save greet($greetchan) 0
    set greet($greetchan) 0
    putdcc $idx "Greets for $greetchan are now disabled."
    return 0
  }
  putdcc $idx "Usage: .greet \[channel\] <on/off>"
  return 0 
}

proc dcc:greethow { handle idx arg } {
  global greet
  global greethow
  if {[llength $arg] < 1} { 
    putdcc $idx "Usage: .greethow \[channel\] \[+flag\] <notice/msg>"
    return 0
  }
  if {[string match "#*" $arg]} {
    set chan [lindex $arg 0]
    set what [lindex $arg 1]
    if {![validchan $chan]} {
      putdcc $idx "I'm not on $chan."
      return 0
    }
    if {[string match "+*" [lindex $arg 1]]} {
      if {[string length [lindex $arg 1]] != 2} {
        putdcc $idx "Only 1 flag is allowed (e.g. +n)."
        return 0
      } {
        set flag [string trimleft [lindex $arg 1] +]
        set what [lindex $arg 2]
      }
    }
  }
  if {[string match "+*" $arg]} {
    if {[string length [lindex $arg 0]] != 2} {
      putdcc $idx "Only 1 flag is allowed (e.g. +n)."
      return 0
    } {
      set flag [string trimleft [lindex $arg 0] +]
      set what [lindex $arg 1]
      set chan [greet:stl [lindex [console $idx] 0]]
      if {$chan == "*"} {
        putdcc $idx "Your console channel is invalid."
        return 0
      }
    }
  }  
  if {![info exists chan]} {
    set chan [greet:stl [lindex [console $idx] 0]]
    set what $arg
    }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""] && ![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $chan]} {
    putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $chan."
    return 0
  }
  if {![string match "+*" $arg] && ![string match "#*" $arg]} {
    set chan [greet:stl [lindex [console $idx] 0]]
    if {$chan == "*"} {
      putdcc $idx "Your console channel is invalid."
      return 0
    }
    set what "[greet:stl $arg]"
  }
  if {[greet:stl $what] == "primvsg" || [greet:stl $what] == "msg"} {
    set what "privmsg"
  } {
    if {[greet:stl $what] == "notice"} {
      set what "notice"
    } {
      putdcc $idx "Don't know how to greet via \"$what\"."  
      return 0
    }
  } 
  if {[info exists flag]} {
    if {$what == "notice"} {
      putcmdlog "#$handle# greethow ($chan) (+$flag) notice"
      greet:save greethow($flag-[greet:stl $chan]) NOTICE 
      set greethow($flag-[greet:stl $chan]) NOTICE
      putdcc $idx "Now greeting +$flag users on $chan via \"NOTICE\"."
      return 0 
    }
    if {$what == "privmsg" || $what == "msg"} {
      putcmdlog "#$handle# greethow ($chan) (+$flag) privmsg"
      greet:save greethow($flag-[greet:stl $chan]) PRIVMSG 
      set greethow($flag-[greet:stl $chan]) PRIVMSG
      putdcc $idx "Now greeting +$flag users on $chan via \"PRIVMSG\"."
      return 0
    }
  }  
  if {$what == "notice"} {
    putcmdlog "#$handle# greethow ($chan) notice"
    greet:save greethow([greet:stl $chan]) NOTICE
    putdcc $idx "Now greeting users on $chan via \"NOTICE\"."
    set greethow([greet:stl $chan]) NOTICE
    return 0
  }
  if {$what == "privmsg" || $what == "msg"} {
    putcmdlog "#$handle# greethow ($chan) privmsg"
    greet:save greethow([greet:stl $chan]) PRIVMSG
    set greethow([greet:stl $chan]) PRIVMSG
    putdcc $idx "Now greeting users on $chan via \"PRIVMSG\"."
    return 0
  }
}

proc dcc:greetwho { handle idx arg } {
  global greet
  global greetall
  if {[llength $arg] < 1} {
    putdcc $idx "Usage: .greetwho \[channel\] <all/known/unkown>"
    return 0
  }
  if {[string match "#*" $arg]} {
    set greetwhat [greet:stl [greet:lend 1 $arg]]
    set greetchan [greet:stl [lindex $arg 0]]
    if {![validchan $greetchan]} {
      putdcc $idx "ERROR: I'm not on $greetchan"
      return 0
    }
  } {
    set greetwhat [lindex [greet:stl $arg] 0] 
    set greetchan [greet:stl [lindex [console $idx] 0]]
    if {$greetchan == "*"} {
      putdcc $idx "Your console channel is invalid."
      return 0
    }
  }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""] && ![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $greetchan]} {
    putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $greetchan."
    return 0
  }
  if {$greetwhat == "all"} {
    set greetall($greetchan) all 
    greet:save greetall($greetchan) all
    putcmdlog "#$handle# greetwho ($greetchan) all"
    putdcc $idx "Now showing greets on $greetchan to all users"
    return 0
  }
 if {$greetwhat == "known"} {
    set greetall($greetchan) known
    greet:save greetall($greetchan) known 
    putcmdlog "#$handle# greetwho ($greetchan) known"
    putdcc $idx "Now showing greets on $greetchan to only known users"
    return 0
  }  
  if {$greetwhat == "unknown"} {
    set greetall($greetchan) unknown
    greet:save greetall($greetchan) unknown 
    putcmdlog "#$handle# greetwho ($greetchan) unknown"
    putdcc $idx "Now showing greets on $greetchan to only unknown users"
    return 0
  }
  putdcc $idx "Usage: .greetwho \[channel\] <all/known/unknown>"
  return 0
}

proc dcc:greetview { handle idx arg } {
  global greet 
  global changreets 
  global greetrand greethow
  if {[llength $arg] < 1} {
    set chan [greet:stl [lindex [console $idx] 0]]
    if {$chan == "*"} {
      putdcc $idx "Your console channel is invalid."
      return 0
    } 
  } {
    set chan [greet:stl [lindex $arg 0]]
  }
  if {![validchan $chan]} {
    putdcc $idx "ERROR: I'm not on $chan"
    return 0
  }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""]} {
    if {![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $chan]} {
      putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $chan."
      return 0
    }
  }
  set greetload "$greet(dir)/channels/[greet:stl [string trimleft $chan #]].dat"
  set greetchan    [greet:load greet([greet:stl $chan])]
  set greetallchan [greet:load greetall([greet:stl $chan])]
  set greethowchan [greet:load greethow([greet:stl $chan])]
  if {[lsearch -exact "NOTICE PRIVMSG MSG" [string toupper $greethowchan]] == "-1"} { 
    set greethowchan $greet(how)
    greet:save greethow([greet:stl $chan]) $greet(how)
  }
  if {[lsearch "all known unknown" $greetallchan] == "-1"} {
    set greetallchan $greet(who)
    greet:save greetall([greet:stl $chan]) $greet(who)
  } 
  putcmdlog "#$handle# greetview $chan"
  putdcc $idx "DISPLAYING GREETS FOR [string toupper $chan]:"
  if {[greet:load greet([greet:stl $chan])] == 0} {
    putdcc $idx " "
    putdcc $idx "Greets are currently DISABLED!"
    putdcc $idx "(use 'greet $chan on' to enable)"
  }
  if {![file exists $greetload]} {
    set file [open $greetload w]
    close $file
  }
  set greetstore ""
  set file [open $greetload r]
  while {![eof $file]} {
    set line [gets $file]
    if {$line != ""} {
      lappend greetstore $line
    }
  }
  close $file
  set greeta "" ; set greetb ""
  foreach line $greetstore {
    if {[string match "+*" $line]} {
      lappend greetflag([lindex $line 0]) "[greet:lend 1 $line]"
      if {[lsearch -exact $greeta [lindex $line 0]] == -1} {
        append greeta "[lindex $line 0] "
      }
    } {
      lappend greetb $line
    }
  }
  set tmp 0
  if {$greeta != "" && [lsearch "$greet(hierarchie)" chan] != -1} {
    set greeta [greet:sort "$greeta" "$greet(sorted)"]
    set tmp 1
    foreach flag $greeta {
      set greethowf($flag) [greet:load greethow([string index $flag 1]-[greet:stl $chan])]
      set greethow($flag-[greet:stl $chan]) $greethowf($flag)
      if {$greethowf($flag) != ""} {
        set greethw $greethowf($flag)
      } {
        set greethw $greethowchan
      }
      putdcc $idx " "
      if {[info exists greetrand($flag-[greet:stl $chan])] && $greetrand($flag-[greet:stl $chan]) == "on"} { 
        putdcc $idx "RANDOM greets for [string toupper [greet:flag2norm $flag]] ($flag) via $greethw:"
      } {
        putdcc $idx "Greets for [string toupper [greet:flag2norm $flag]] ($flag) via $greethw:"
      }
      foreach line $greetflag($flag) {
        if {![info exists countf($flag)]} { set countf($flag) 1 } { incr countf($flag) }
        if {$countf($flag) > $greet(max) && $greet(max) != "0"} {
        if {![info exists rbla] && $greetrand($flag-[greet:stl $chan]) != "on"} {
          putdcc $idx " WARNING: The following lines are only available on RANDOM greets:"
          set rbla 1
        }
      }
        putdcc $idx "  $countf($flag): $line"
      }
    }
  }
  if {$greetb != "" && [lsearch "$greet(hierarchie)" chan] != -1} {
    set tmp 1
    putdcc $idx " "
    if {[info exists greetrand([greet:stl $chan])] && $greetrand([greet:stl $chan]) == "on"} {
      putdcc $idx "RANDOM greets for [string toupper $greetallchan] users via $greethowchan:"
    } {
      putdcc $idx "Greets for [string toupper $greetallchan] users via $greethowchan:"
    } 
    set count 0
    set rand [greet:load greetrand([greet:stl $chan])]
    foreach line $greetb {
      incr count
      if {$count > $greet(max) && $greet(max) != "0"} {
        if {![info exists rbla] && $rand != "on"} {
          putdcc $idx " WARNING: The following lines are only available on RANDOM greets:"
          set rbla 1
        }
      }
      putdcc $idx "  $count: $line"
    }
  }
  if {$tmp == 0 && [lsearch "$greet(hierarchie)" chan] != -1} {
    putdcc $idx " "
    putdcc $idx "There are currently no changreets saved."
    putdcc $idx "(use .+greet $chan \[+flag\] <greet>)"
  }
  set hostsgreets [greet:getfile $greet(dir)/channels/[string trimleft $chan #].host]
  if {$hostsgreets != "" && [lsearch "$greet(hierarchie)" mask] != -1} {
    foreach line $hostsgreets { 
      if {![info exists hostgr([lindex $line 0])]} { set hostgr([lindex $line 0]) [greet:lend 1 $line] } { lappend hostgr([lindex $line 0]) [greet:lend 1 $line] }
    }
    foreach host [array names hostgr] {
      putdcc $idx " "
      putdcc $idx "Greets for $host (MASK) users:"
      set mfoo 0
      foreach line $hostgr($host) {
        putdcc $idx "  [incr mfoo]: $line"
      }
    }  
  } {
    if {[lsearch "$greet(hierarchie)" mask] != -1} {
      putdcc $idx " "
      putdcc $idx "There are currently no maskgreets saved."
      putdcc $idx "(use .+greetmask $chan <nick!ident@host> <greet>)"
    }
  }
  set changreets([greet:stl $chan]) [greet:getfile $greet(dir)/channels/[string trimleft $chan #].dat]
  set hostgreets([greet:stl $chan]) $hostsgreets
  return 0 
}

proc dcc:+greetfile { handle idx arg } {
  global greet
  global changreets 
  global files-path
  if {![info exists files-path]} {
    putdcc $idx "This command is not availabe, because filesys has not yet been set active."
    return 0
  } 
  if {[llength $arg] < 1} {
    putdcc $idx "Usage: .+greetfile \[channel\] \[+flag\] <filename>"
    return 0
  }
  if {[llength $arg] < 2} {
    if {[string match "#*" $arg]} {
      putdcc $idx "Usage: .+greetfile \[channel\] \[+flag\] <filename>"
      return 0
    }
  }
  set greetflags ""
  if {[string match "#*" $arg]} {
    if {[string match "+*" [lindex $arg 1]]} {
      set greethow [greet:lend 2 $arg]
      set greetflags [lindex $arg 1]
      set greetchan [lindex $arg 0]
    } {
      set greethow [greet:lend 1 $arg]
      set greetchan [lindex $arg 0]
    }
    if {![validchan $greetchan]} {
      putdcc $idx "ERROR: I'm not on $greetchan"
      return 0
    }
  } {
    if {[string match "+*" [lindex $arg 0]]} {
      set greethow [greet:lend 1 $arg]
      set greetflags [lindex $arg 0]
      set greetchan [lindex [console $idx] 0]
    } {
      set greethow $arg
      set greetchan [lindex [console $idx] 0]
    }
  }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""]} {
    if {![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $greetchan]} {
      putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $greetchan"
      return 0
    }
  }
  if {[string length $greetflags] > 2} {
    putdcc $idx "ERROR: only 1 flag is allowed, e.g. +greetfile +n <filename>"
    return 0
  }
  if {$greetchan == "*"} {
    putdcc $idx "Your console channel is invalid."
    return 0
  }
  if {$greethow == ""} {
    putdcc $idx "Usage: .+greetfile \[channel\] \[+flag\] <filename>"
    return 0
  }
  if {[string match "/*" $greethow] || [string match "*..*" $greethow]} {
    putdcc $idx "ERROR: Only files, which are saved in the filearea are allowed."
    return 0
  }
  if {![string match "*/" ${files-path}]} { append files-path "/" } 
  if {![file exists ${files-path}$greethow]} {
    putdcc $idx "ERROR: No such file in the filearea: $greethow."
    return 0
  }
  if {![file readable ${files-path}$greethow]} {
    putdcc $idx "ERROR: can't read file: $greethow (check permissions)"
    return 0
  }
  set validflags "abcdefghijklmnopqrstuvwxyz1234567890"
  if {$greetflags != "" && [lsearch -exact [split $validflags ""] [greet:stl [string trimleft $greetflags +]]] == -1} {
    putdcc $idx "ERROR: $greetflags is no valid flag."
    return 0
  }
  set greetsave "$greet(dir)/channels/[greet:stl [string trimleft $greetchan #]].dat"
  set file [open $greetsave r]
  while {![eof $file]} {
    set line [gets $file]
    if {$line != ""} {
      if {[string match "+*" $line]} {
        if {![info exists count([lindex $line 0])]} {
          set count([lindex $line 0]) 1
	} {
          incr count([lindex $line 0])
	}
      } {
        if {![info exists count(all)]} {
          set count(all) 1
        } {
          incr count(all)
        }
      }
    }   
  }
  close $file 
  if {$greetflags == ""} { 
    if {[info exists count(all)]} { set rcount $count(all) } { set rcount 0 }
  } { 
    if {[info exists count($greetflags)]} { set rcount $count($greetflags) } { set rcount 0 }
  }
  if {[greet:ispermown $handle]} {
    set index [greet:getfile ${files-path}$greethow]
    set lcount 0
    set file [open $greetsave a+]
    foreach line $index {
      incr lcount
      if {$greetflags == ""} {
        puts $file $line
      } {
        puts $file "$greetflags $line"
      }
    }  
    close $file
    if {$greetflags == ""} {
      putcmdlog "#$handle# +greetfile ($greetchan) $greethow"
      putdcc $idx "Added $lcount lines from \"$greethow\" for $greetchan."
    } {
      putcmdlog "#$handle# +greetfile ($greetchan) ($greetflags) $greethow"
      putdcc $idx "Added $lcount lines from \"$greethow\" for $greetflags users on $greetchan."
    }
    set changreets([greet:stl $greetchan]) [greet:getfile $greetsave]
    return 0 
  }
  set index [greet:getfile ${files-path}$greethow]
  set file [open $greetsave a+]
  foreach line $index {
    if {$rcount > $greet(max) && $greet(max) != "0"} {
      if {$greetflags == ""} {
        putdcc $idx "No more lines allowed for greets on $greetchan."
      } {
        putdcc $idx "No more lines allowed for $greetflags greets on $greetchan."
      }
      putcmdlog "#$handle# +greetfile ($greetchan) $greethow"   
      putdcc $idx "Added $rcount lines of \"$greethow\" on $greetchan."  
      close $file
      return 0
    }
    incr rcount
    if {$greetflags == ""} {
      puts $file $line
    } {
      puts $file "$greetflags $line"
    }
  }  
  close $file
if {$greetflags == ""} {
    putcmdlog "#$handle# +greetfile ($greetchan) $greethow"
    putdcc $idx "Added \"$greethow\" for greets on $greetchan. ($rcount lines)"
  } {
    putcmdlog "#$handle# +greetfile ($greetchan) ($greetflags) $greethow"
    putdcc $idx "Added \"$greethow\" for $greetflags greets on $greetchan. ($rcount lines)"
  }
  set changreets([greet:stl $greetchan]) [greet:getfile $greetsave]
  return 0 
}

proc dcc:-greetmask { handle idx arg } {
  global greet 
  global hostgreets
  if {[llength $arg] < 1} {
    putdcc $idx "Usage: .-greetmask \[channel\] <nick!ident@host> <linenr>"
    putdcc $idx "   or: .-greetmask \[channel\] <all>"
    return 0
  }
  if {[string match "#*" $arg]} {
    set chan [lindex $arg 0]
    if {![validchan $chan]} {
      putdcc $idx "I'm not on $chan."
      return 0
    }
    set hostmask [lindex $arg 1]
    set sc [lindex $arg 2]
  } {
    set chan [lindex [console $idx] 0]
    set hostmask [lindex $arg 0]
    set sc [lindex $arg 1]
  }
  if {[greet:stl $hostmask] == "all"} {
    if {[greet:getfile $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host] == ""} {
      putdcc $idx "Error: no maskgreets saved on $chan."
      return 0
    }
    set file [open $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host w]
    close $file
    putcmdlog "#$handle# -greetmask $arg ($chan)"
    putdcc $idx "Deleted all maskgreets on $chan."
    return 0
  }
  if {$sc == 0} {
    putdcc $idx "Can't delete 0!"
    return 0
  }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""] && ![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $chan]} {
    putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $chan."
    return 0
  }
  if {[string length $hostmask] < 8} {
    putdcc $idx "Please use a longer mask. (at least 8 characters)."
    return 0
  }
  set hostgreets([greet:stl $chan]) [greet:getfile $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host]
  if {![file exists $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host]} {
    set file [open $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host w]
    close $file
    putdcc $idx "There are currently no maskgreets saved on $chan."
  }
  if {![greet:isdigit $sc]} {
    if {[greet:stl $sc] == "all"} {
      putdcc $idx "Deleted maskgreets on $greetchan."
      return 0
    }
    putdcc $idx "Usage: .-greetmask \[channel\] <nick!ident@host> <linennr/all>"
    return 0
  }
  set count 0
  foreach line $hostgreets([greet:stl $chan]) {
    if {[string match "$hostmask *" $line]} { incr count }
  }
  if {$sc > $count} {
    putdcc $idx "ERROR: Only $count $hostmask greets on $chan."
    return 0
  }
  set file [open $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host w]
  set count 0
  foreach line $hostgreets([greet:stl $chan]) {
    if {[string match "$hostmask *" $line]} { 
      incr count 
      if {$count == $sc} { set found $line } { puts $file $line }
    } {
      puts $file $line
    }
  }  
  close $file  
  if {[string length $found] > 25} { set found "[string range $found 0 25]..." }
  putdcc $idx "Deleted greet $sc ($hostmask) on $chan: [greet:lend 1 $found]"
  return 0 
}  

proc dcc:+greetmask { handle idx arg } {
  global greet 
  global hostgreets
  if {[llength $arg] < 2} {
    putdcc $idx "Usage: .+greetmask \[channel\] <nick!ident@host> <greet>"
    return 0
  }
  if {[string match "#*" $arg]} {
    set chan [lindex $arg 0]
    if {![validchan $chan]} {
      putdcc $idx "I'm not on $chan."
      return 0
    }
    set hostmask [lindex $arg 1]
    set greettxt [greet:lend 2 $arg]
  } {
    set chan [lindex [console $idx] 0]
    set hostmask [lindex $arg 0]
    set greettxt [greet:lend 1 $arg]
  }
  if {[llength $greettxt] < 1} {
    putdcc $idx "Usage: .+greetmask \[channel\] <nick!ident@host> <greet>"
    return 0
  }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""] && ![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $chan]} {
    putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $chan."
    return 0
  }
  if {[string length $hostmask] < 8} {
    putdcc $idx "Please use a longer mask. (at least 8 characters)."
    return 0
  }
  if {![string match "*@*.*" $hostmask]} {
    putdcc $idx "Not a valid mask: $hostmask (use this format: nickname!ident@host.domain)"
    putdcc $idx "Wildcards (* and ?) are allowed."
    return 0
  }
  if {![file exists $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host]} {
    set file [open $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host w]
    close $file
    set hfile ""
  } {
    set hfile [greet:getfile $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host]
  }
  set count 0
  foreach line $hfile { incr count }
  if {$count > $greet(max) && $greet(max) != "0"} {
    putdcc $idx "No more lines are allowed for mask greets on $chan."
    set hostgreets([greet:stl $chan]) [greet:getfile $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host]
    return 0
  }
  set file [open $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host a+]
  puts $file "$hostmask $greettxt"
  close $file
  putcmdlog "#$handle# +greetmask ($chan) $greettxt"
  putdcc $idx "Added \"$greettxt\" for mask $hostmask on $chan."
  set hostgreets([greet:stl $chan]) [greet:getfile $greet(dir)/channels/[string trimleft [greet:stl $chan] #].host]
  return 0 
}
  
proc dcc:+greet { handle idx arg } {
global greet 
global changreets
  if {[llength $arg] < 1} {
    putdcc $idx "Usage: .+greet \[channel\] \[+flag\] <greet>"
    return 0
  }
  if {[llength $arg] < 2} {
    if {[string match "#*" $arg]} {
      putdcc $idx "Usage: .+greet \[channel\] \[+flag\] <greet>"
      return 0
    }
  }
  set greetflags ""
  if {[string match "#*" $arg]} {
    if {[string match "+*" [lindex $arg 1]]} {
      set greethow [greet:lend 2 $arg]
      set greetflags [lindex $arg 1]
      set greetchan [lindex $arg 0]
    } {
      set greethow [greet:lend 1 $arg]
      set greetchan [lindex $arg 0]
    }
    if {![validchan $greetchan]} {
      putdcc $idx "ERROR: I'm not on $greetchan"
      return 0
    }
  } {
    if {[string match "+*" [lindex $arg 0]]} {  
      set greethow [greet:lend 1 $arg]
      set greetflags [lindex $arg 0]
      set greetchan [lindex [console $idx] 0]
    } {
      set greethow $arg
      set greetchan [lindex [console $idx] 0]
    }
  }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""]} {
    if {![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $greetchan]} {
      putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $greetchan"
      return 0
    }
  }
  if {[string length $greetflags] > 2} {
    putdcc $idx "ERROR: only 1 flag is allowed, e.g. +greet +n <greet>"
    return 0
  }
  if {$greetchan == "*"} {
    putdcc $idx "Your console channel is invalid."
    return 0
  }
  if {$greethow == ""} {
    putdcc $idx "Usage: .+greet \[channel\] \[+flag\] <greet>"
    return 0
  }
  if {$greetflags != ""} {
    set validflags "abcdefghijklmnopqrstuvwxyz1234567890"
    if {[lsearch -exact [split $validflags ""] [greet:stl [string trimleft $greetflags +]]] == -1} {
      putdcc $idx "ERROR: $greetflags is no valid flag."
      return 0
    }
  }
  set greetsave "$greet(dir)/channels/[greet:stl [string trimleft $greetchan #]].dat"
  set count 0
  if {[file exists $greetsave]} {
    set file [open $greetsave r]
    while {![eof $file]} {
      set line [gets $file]
      if {$line != ""} { if {$greetflags != ""} { if {[string match "$greetflags *" $line]} { incr count } } { if {![string match "+*" $line]} { incr count } } } } 
    close $file
  } {
    set file [open $greetsave w]
    close $file
  }
  set file [open $greetsave a+]
  if {$greetflags == ""} { puts $file "$greethow" } { puts $file "$greetflags $greethow" } 
  close $file
  if {$greetflags != ""} { putdcc $idx "Added \"$greethow\" ($greetflags users) for $greetchan." } { putdcc $idx "Added \"$greethow\" for $greetchan." }
  if {$count >= $greet(max) && $greet(max) != "0"} {
    putdcc $idx "WARNING: This line is only available on RANDOM greets."
  }
  set changreets([greet:stl $greetchan]) ""
  set file [open $greetsave r]
  while {![eof $file]} {
    set line [gets $file]
    if {$line != ""} {
      lappend changreets([greet:stl $greetchan]) $line
    }
  }
  close $file
}

proc dcc:getgwv { handle idx arg } {
  global greet
  global botnet-nick version
  global greetidx 
  if {[info exists greetidx]} {
    putdcc $idx "Currently there is a .greetver is process..."
    return 0
  }
  putdcc $idx "BOTNICK   | GreetVer | Eggdrop"
  putdcc $idx "[format "%-9s | %-8s" ${botnet-nick} $greet(version)] | [string range [lindex $version 0] 0 2].x"
  set greetidx $idx
  putallbots "sg_info"
  putallbots "gw_info"
  utimer 15 "unset greetidx"
}

proc gw_version { from key arg } {
  global greet 
  global version 
  global greetidx
  if {[info exists greetidx] && [valididx $greetidx]} {
    if {[lindex $arg 1] != ""} {
      putdcc $greetidx "[format "%-9s | %-8s" $from [lindex $arg 0]] | [string range  [lindex $arg 1] 0 2].x"
    } {
      putdcc $greetidx "[format "%-9s | %-8s" $from [lindex $arg 0]] | n.a."
    }
  }
}

proc bot:sginfo { bot com arg } {
  global greet 
  global version
  putbot $bot "gw_version $greet(version) [string range [lindex $version 0] 0 2].x"
}

proc dcc:-greet { handle idx arg } {
  global greet 
  global changreets
  if {[llength $arg] < 1} {
    putdcc $idx "Usage: .-greet \[channel\] \[+flag\] <linenr/all>"
    return 0
  }
  if {[llength $arg] < 2} {
    if {[string match "#*" $arg]} {
      putdcc $idx "Usage: .-greet \[channel\] \[+flag\] <linenr/all>"
      return 0
    }
  }
  set greetflags ""
  if {[string match "#*" $arg]} {
    if {[string match "+*" [lindex $arg 1]]} {
      set greethow [greet:lend 2 $arg]
      set greetflags [lindex $arg 1]
      set greetchan [lindex $arg 0]
    } {
      set greethow [greet:lend 1 $arg]
      set greetchan [lindex $arg 0]
    }
    if {![validchan $greetchan]} {
      putdcc $idx "ERROR: I'm not on $greetchan"
      return 0
    }
  } {
    if {[string match "+*" [lindex $arg 0]]} {
      set greethow [greet:lend 1 $arg]
      set greetflags [lindex $arg 0]
      set greetchan [lindex [console $idx] 0]
    } {
      set greethow $arg
      set greetchan [lindex [console $idx] 0]
    }
  }
  if {![greet:matchattr $handle [lindex [split $greet(rbind) |] 0] ""]} {
    if {![greet:matchattr $handle |[lindex [split $greet(rbind) |] 1] $greetchan]} {
      putdcc $idx "Sorry, you don't have +[lindex [split $greet(rbind) |] 1] on $greetchan."
      return 0
    }
  }
  if {[string length $greetflags] > 2} {
    putdcc $idx "ERROR: only 1 flag is allowed, e.g. -greet +n <linenr>"
    return 0
  }
  if {$greetchan == "*"} {
    putdcc $idx "Your console channel is invalid."
    return 0
  }
  if {$greetflags != ""} {
    set validflags "abcdefghijklmnopqrstuvwxyz1234567890"
    if {[lsearch -exact [split $validflags ""] [greet:stl [string trimleft $greetflags +]]] == -1} { putdcc $idx "ERROR: $greetflags is no valid flag." ; return 0 }
  } 
  set greetsave "$greet(dir)/channels/[greet:stl [string trimleft $greetchan #]].dat"
  if {$greethow == "all"} {
    set file [open $greetsave r]
    if {$greetflags == ""} {
      while {![eof $file]} {
        set line [gets $file]
        if {[string match "+*" $line]} { lappend foo $line } { if {$line != ""} {set loo 1} }
      }
      if {![info exists loo]} { putdcc $idx "No greets saved on $greetchan." } { putdcc $idx "Deleted all non-flag-greets on $greetchan." }
    } {
      while {![eof $file]} {
        set line [gets $file]
        if {![string match "$greetflags *" $line]} {lappend foo $line} {set loo 1}
      }
      if {![info exists loo]} {
        putdcc $idx "No greets for $greetflags users saved on $greetchan."
      } {
        putdcc $idx "Deleted all greets for $greetflags users on $greetchan."
      }
    }
    close $file
    if {![info exists foo]} { set file [open $greetsave w] ; close $file } { set file [open $greetsave w] ; foreach l $foo { puts $file $l } ; close $file }
    return 0 
  }
  foreach count [split $greethow ""] {
    if {[lsearch -exact "0 1 2 3 4 5 6 7 8 9" $count] == -1} {
      putdcc $idx "Usage: .-greet \[channel\] \[+flag\] <linenr/all>"
      return 0
    }
  }
  set greetnew "" ; set greetfound 0 ; set count 0 ; set fcount 0
  set file [open $greetsave r] 
  while {![eof $file]} {
    set line [gets $file]
    if {$line != ""} {
      lappend greetnew $line
      incr fcount
      if {$greetflags == ""} {
        if {![string match "+*" $line]} { 
          incr count
          if {$count == $greethow} {set foundcount $fcount}
        }
      } {
        if {[string match "$greetflags *" $line]} {
          incr count
          if {$count == $greethow} {set foundcount $fcount}
	}
      }	
    }
  }
  close $file
  if {$count < $greethow} {
    if {$greetflags == ""} {
      putdcc $idx "ERROR: Only $count greets on $greetchan."
    } {
      putdcc $idx "ERROR: Only $count greets for $greetflags users on $greetchan."
    }
    return 0
  }
  if {$greethow == 0} { putdcc $idx "ERROR: Can't delete 0." ; return 0 }
  set searchcount 0
  set file [open $greetsave w]  
  foreach line $greetnew  {
   incr searchcount
   if {$searchcount == $foundcount} { set found $line } { puts $file $line }
 }
  close $file    
  if {[string length $found] > 25} { set found "[string range $found 0 25]..." }
  if {$greetflags == ""} { putdcc $idx "Deleted greet $greethow on $greetchan: $found" } { putdcc $idx "Deleted greet $greethow ($greetflags users) on $greetchan: [greet:lend 1 $found]" }
  set changreets([greet:stl $greetchan]) [greet:getfile $greetsave]
  return 0
}
# --- end: commands (dcc) ---

# --- greet procs ---
# greet:join
# greet:chan
# greet:nick
# greet:host
# putgreet
# greet:qudecr
# greet:clrqueue
# raw:greetfoo
# greet:replace
proc greet:replace { nick chan line } {
  global botnick
  if {[string match "*greet-nick*" $line]} { regsub -all greet-nick $line $nick line }
  if {[string match "*greet-chan*" $line]} { regsub -all greet-chan $line $chan line }
  if {[string match "*greet-botnick*" $line]} { regsub -all greet-botnick $line $botnick line }
  return $line
}

bind join -|- *!*@* greet:join
proc greet:join { nick uhost handle chan } {
  global greet 
  global botnick 
  global nickgreets changreets hostgreets
  global greetflood greethow greetall greetrand
  set realchan $chan
  set chan [greet:stl $chan]
  global greetsplit
  if {![info exists greetsplit]} { set greetsplit "" }
  if {[lsearch -exact "$greetsplit" $uhost] != -1} { return 1 }
  if {$greet(floodprotect) == 1} { greet:flooddetect $nick $uhost $handle $chan }
  if {$nick == $botnick || [greet:matchattr $handle b ""]} { return 0 }
  if {[info exists greetflood($chan)]} { return 0 }
  if {![info exists greet($chan)]} { set greet($chan) [greet:save greet($chan) "1"] }
  if {![info exists greetall($chan)]} { set greetall($chan) [greet:save greetall($chan) "$greet(who)"] }
  if {![info exists greethow($chan)]} { set greethow($chan) [greet:save greethow($chan) "$greet(how)"] }
  if {![info exists changreets($chan)]} { 
    if {![file exists $greet(dir)/channels/[string trimleft $chan #].dat]} {
      set file [open $greet(dir)/channels/[string trimleft $chan #].dat w]
      close $file 
      set changreets($chan) ""
      putlog "GreetWondeR $greet(version) - Can't find channelfile for $realchan: created."
    } {
      set changreets($chan) [greet:getfile $greet(dir)/channels/[string trimleft $chan #].dat] 
    } 
  }  
  if {![info exists nickgreets]} { set nickgreets [greet:getfile $greet(dir)/$greet(nicks)] }
  if {![info exists hostgreets($chan)]} {
    if {![file exists $greet(dir)/channels/[string trimleft $chan #].host]} {
      set file [open $greet(dir)/channels/[string trimleft $chan #].host w]
      close $file
      set hostgreets($chan) ""
    } {
      set hostgreets($chan) [greet:getfile $greet(dir)/channels/[string trimleft $chan #].host]
    }
  }
  if {![info exists greet($chan)]} { set greet($chan) [greet:load greet($chan)] } 
  if {$greet($chan) == 0 || $changreets($chan) == "" && $hostgreets($chan) == "" && $nickgreets == ""} {
    return 0
  }
  for {set i 0} {$i < [llength $greet(hierarchie)]} { incr i } {
    switch -exact [lindex $greet(hierarchie) $i] {
      "nick" { if {$nickgreets != ""} { if {[greet:nick $nick $handle $realchan]} { return 1 } } } 
      "chan" { if {$changreets($chan) != ""} { if {[greet:chan $nick $handle $realchan]} { return 1 } } } 
      "mask" { if {$hostgreets($chan) != ""} { if {[greet:host $nick $uhost $realchan]} { return 1 } } } 
    }
  }  
  return 0
}

proc greet:chan { nick handle chan } {
  global greet 
  global botnick 
  global changreets greetflood greethow greetall greetrand
  set realchan $chan
  set chan [greet:stl $chan]
  foreach line $changreets($chan) { if {[string match "+*" $line]} { lappend greetflag([lindex $line 0]) [greet:lend 1 $line] } { lappend greetnorm $line } }
  if {[array names greetflag] != ""} {
    set greeta [greet:sort [array names greetflag] "$greet(sorted)"]
    foreach flag $greeta {
      if {[greet:matchattr $handle $flag ""] || [greet:matchattr $handle |$flag $chan]} {
        if {![info exists greethow([string index $flag 1]-$chan)]} { 
	  set greethow([string index $flag 1]-$chan) [greet:load greethow([string index $flag 1]-$chan)]
	}
        if {$greethow([string index $flag 1]-$chan) == ""} {
	  set greethow([string index $flag 1]-$chan) [greet:save greethow([string index $flag 1]-$chan) $greethow($chan)]
	}
        if {[info exists greetrand($flag-$chan)] && $greetrand($flag-$chan) == "on"} {
          putgreet $greethow([string index $flag 1]-$chan) $nick "[greet:replace $nick $realchan [lindex $greetflag($flag) [rand [expr [llength $greetflag($flag)] -1]]]]"
          set exec 1
        } {
          if {$greet(flag_greet_seperation) == "off"} {if {[info exists foo]} {if {$foo != $flag} {return 1} } }
          set greetcount 0
          foreach line $greetflag($flag) {
            incr greetcount
            if {$greetcount > $greet(max)} { return 1 }
            set foo $flag 
            putgreet $greethow([string index $flag 1]-$chan) $nick "[greet:replace $nick $realchan $line]"
	    set exec 1
   	  }
	}
      }
    }
  }
  if {$greetall($chan) == "known" && $handle == "*"} { return 0 }
  if {$greetall($chan) == "unknown" && $handle != "*"} { return 0 }
  if {[info exists greetnorm] && ![info exists exec]} {
    if {[info exists greetrand($chan)] && $greetrand($chan) == "on"} {
      putgreet $greethow($chan) $nick "[greet:replace $nick $realchan [lindex $greetnorm [rand [expr [llength $greetnorm] -1]]]]"
      set exec 1
    } {
      set greetcount 0
      foreach line $greetnorm {
        incr greetcount
        if {$greetcount > $greet(max)} { return 1 }
        putgreet $greethow($chan) $nick "[greet:replace $nick $realchan $line]"
      }
      set exec 1
    }  
  }
  if {[info exists exec]} { return 1 } { return 0 }
}

proc greet:nick { nick handle chan } { 
  global greet 
  global botnick
  global nickgreets greetflood greethow greetall greetrand
  set realchan $chan
  set chan [greet:stl $chan]
  if {$handle == "*"} { return 0 }
  foreach line $nickgreets {
    if {[string match "$handle *" $line]} {
      switch -exact [string toupper [lindex $line 1]] {
        "PUBLIC"  { putgreet PRIVMSG $chan "[greet:replace $nick $realchan [greet:lend 2 $line]]" ; return 1 }
        "NOTICE"  { putgreet NOTICE $nick "[greet:replace $nick $realchan [greet:lend 2 $line]]"  ; return 1 }
        "PRIVMSG" { putgreet PRIVMSG $nick "[greet:replace $nick $realchan [greet:lend 2 $line]]" ; return 1 }
        "ACTION"  { putgreet PRIVMSG $chan "\001ACTION [greet:replace $nick $realchan [greet:lend 2 $line]]\001" ; return 1 }
      }
    }
  }
  return 0
}  

proc greet:host { nick uhost chan } {
  global greet 
  global botnick 
  global greetflood hostgreets greethow greetall greetrand
  set realchan $chan
  set chan [greet:stl $chan]
  foreach line $hostgreets($chan) { if {[string match "[greet:stl [lindex $line 0]]" "[greet:stl $nick!$uhost]"]} { set matched 1 } }
  set greetcount 0
  foreach line $hostgreets($chan) {
    if {[string match "[greet:stl [lindex $line 0]]" "[greet:stl $nick!$uhost]"]} {
      incr greetcount
      if {$greetcount > $greet(max)} { return 1 }
      set exec 1
      putgreet $greethow($chan) $chan "[greet:replace $nick $chan [greet:lend 1 $line]]"
    }
  }
  if {[info exists exec]} { return 1 } { return 0 }
}

proc putgreet { how nick string } {
  global greet
  global gqueue grqueue
  global footimer dftimer
  if {[info exists dftimer] || [info exists footimer]} { putserv "$how $nick :$string" ; return 1 }
  if {[lindex [split $greet(sendq) :] 0] == 0 || [lindex [split $greet(sendq) :] 1]== 0} { putserv "$how $nick :$string"; return 1 }
  if {![info exists gqueue(cbytes)]} { set gqueue(cbytes) 0 }
  if {![info exists gqueue(ccmds)]}  { set gqueue(ccmds) 0 }
  if {![info exists gqueue(gfp)]}    { set gqueue(gfp) 0 }
  if {![info exists greet(counter)]} { set greet(counter) 0 }
  if {![info exists greet(lcount)]}  { set greet(lcount) 0 }
  if {![info exists greet(csecs)]}   { set greet(csecs) 0 }
  set gqueue(cbytes) [expr $gqueue(cbytes) + [string length "$how $nick :$string"]]
  incr gqueue(ccmds)
  if {$gqueue(gfp)} {
    if {[string length $grqueue] <= $greet(maxqueue) || [llength $grqueue] <= $greet(maxcmds)} {
      lappend grqueue "$how $nick :$string"
      return 0
    } {
      incr gqueue(ccmds) -1
      set gqueue(cbytes) [expr $gqueue(cbytes) - [string length "$how $nick :$string"]]
      greet:save greet(lcount) [incr greet(lcount)]
      return 0
    }
  }
  if {$gqueue(cbytes) >= [lindex [split $greet(sendq) :] 0] || $gqueue(ccmds) >= $greet(sendc)} {
    set gqueue(gfp) 1
    lappend grqueue "$how $nick :$string"
    foreach utimer [utimers] { if {[string match "greet:qudecr *" [lindex $utimer 1]]} { killutimer [lindex $utimer 2]}}
    putserv "GFOO"
    return 0
  }
  set greet(footimer) [utimer [lindex [split $greet(sendq) :] 1] "greet:qudecr [string length "$how $nick :$string"]"]
  putserv "$how $nick :$string"
  greet:save greet(counter) [incr greet(counter)]
}

proc greet:qudecr { bytes } {
  global gqueue
  set gqueue(cbytes) [expr $gqueue(cbytes) - $bytes]
  incr gqueue(ccmds) -1
}

proc raw:greetfoo { from key arg } {
  if {[lindex $arg 1] == "GFOO"} { greet:clrqueue }
}

proc greet:clrqueue {} {
  global greet
  global gqueue grqueue clrfoo
  set clrfoo 0 ; set gqueue(cbytes) 0 ; set grqueue2 "" ; set gqueue(ccmds) 0
  if {![info exists greet(counter)]} { set greet(counter) 0 }
  foreach greetline $grqueue {
    set gqueue(cbytes) [expr $gqueue(cbytes) + [string length "$greetline"]]
    incr gqueue(ccmds)
    if {$gqueue(cbytes) >= [lindex [split $greet(sendq) :] 0] || $gqueue(ccmds) >= $greet(sendc)} {
      lappend grqueue2 $greetline
      if {!$clrfoo} { 
        set clrfoo 1 ; putserv "GFOO"
        foreach utimer [utimers] { if {[string match "greet:qudecr *" [lindex $utimer 1]]} { killutimer [lindex $utimer 2]}}
      }
    } {
      set greet(footimer) [utimer [lindex [split $greet(sendq) :] 1] "greet:qudecr [string length "$greetline"]"]
      putserv "$greetline" ; greet:save greet(counter) [incr greet(counter)]
    }
  }
  set grqueue $grqueue2
  set gqueue(gfp) $clrfoo
}
# --- end: greet procs ---

# --- EOC - END OF CODE GreetWondeR v1.8.2 ---
